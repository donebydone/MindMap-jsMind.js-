"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/stores/mapStore.ts":
/*!********************************!*\
  !*** ./src/stores/mapStore.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _barrel_optimize_names_message_notification_antd__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=message,notification!=!antd */ \"(app-pages-browser)/./node_modules/antd/es/message/index.js\");\n/* harmony import */ var _barrel_optimize_names_message_notification_antd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=message,notification!=!antd */ \"(app-pages-browser)/./node_modules/antd/es/notification/index.js\");\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _utils_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/data */ \"(app-pages-browser)/./src/utils/data.ts\");\n\n\n\n\nconst cancelToken = axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].CancelToken;\nlet cancel;\nconst defaultReturnCommand = {\n    commandName: \"\",\n    assistantId: \"\",\n    threadId: \"\",\n    commands: \"\",\n    select: \"\",\n    idea: [\n        0,\n        0\n    ],\n    context: [\n        0,\n        0\n    ],\n    content: [\n        0,\n        0\n    ],\n    commandKey: new Date().toString()\n};\nconst defaultMindMap = {\n    meta: {\n        name: \"MindMap\",\n        version: \"0.2\"\n    },\n    format: \"node_array\",\n    projectName: \"Default Project\",\n    data: [\n        {\n            id: \"root\",\n            isroot: true,\n            topic: \"MindMap\",\n            type: \"root\"\n        }\n    ],\n    RequestInstruction: \"\",\n    configuration: {\n        openAIKey: \"\",\n        defaultAssistantId: \"\",\n        defaultThreadId: \"\",\n        commands: []\n    }\n};\nconst createNodeData = (node)=>{\n    return {\n        id: node.id,\n        parentid: node.parent ? node.parent.id : undefined,\n        isroot: node.parent ? false : true,\n        topic: node.topic,\n        type: node.data.type\n    };\n};\nconst jsonToXML = (mindMap)=>{\n    const includedNodeIds = new Set();\n    const getNodeXML = (node)=>{\n        let backgroundColor = \"\";\n        if (node.type === \"Idea\") {\n            backgroundColor = \"#008000\"; // Green\n        } else if (node.type === \"Context\") {\n            backgroundColor = \"#808080\"; // Grey\n        } else if (node.type === \"Content\") {\n            backgroundColor = \"#FFFFFF\"; // White\n        }\n        const children = mindMap.filter((n)=>n.parentid === node.id);\n        const childrenXML = children.map(getNodeXML).join(\"\");\n        includedNodeIds.add(node.id);\n        return '<node ID=\"'.concat(node.id, '\" TEXT=\"').concat(node.topic, '\"').concat(node.isroot ? ' ROOT=\"true\"' : \"\", ' BACKGROUND_COLOR=\"').concat(backgroundColor, '\">').concat(childrenXML, \"</node>\");\n    };\n    const rootNode = mindMap.find((n)=>n.isroot) || mindMap[0];\n    let xmlString = '<map version=\"1.0.1\">\\n<!-- To view this file, download free mind mapping software FreeMind from http://freemind.sourceforge.net -->\\n';\n    if (rootNode) {\n        xmlString += \"\".concat(getNodeXML(rootNode), \"\\n\");\n    } else {\n        mindMap.forEach((node)=>{\n            if (!includedNodeIds.has(node.id)) {\n                xmlString += \"\".concat(getNodeXML(node), \"\\n\");\n            }\n        });\n    }\n    xmlString += \"</map>\";\n    return xmlString;\n};\nconst jsonToXMLFiltering = (mindMap)=>{\n    const includedNodeIds = new Set();\n    const getNodeXML = (node)=>{\n        let backgroundColor = \"\";\n        if (node.data.type === \"Idea\") {\n            backgroundColor = \"#008000\"; // Green\n        } else if (node.data.type === \"Context\") {\n            backgroundColor = \"#808080\"; // Grey\n        } else if (node.data.type === \"Content\") {\n            backgroundColor = \"#FFFFFF\"; // White\n        }\n        const children = mindMap.filter((n)=>{\n            var _n_parent;\n            return ((_n_parent = n.parent) === null || _n_parent === void 0 ? void 0 : _n_parent.id) === node.id;\n        });\n        const childrenXML = children.map(getNodeXML).join(\"\");\n        includedNodeIds.add(node.id);\n        return '<node ID=\"'.concat(node.id, '\" TEXT=\"').concat(node.topic, '\"').concat(node.isroot ? ' ROOT=\"true\"' : \"\", ' BACKGROUND_COLOR=\"').concat(backgroundColor, '\">').concat(childrenXML, \"</node>\");\n    };\n    const rootNode = mindMap.find((n)=>n.isroot) || mindMap[0];\n    let xmlString = '<map version=\"1.0.1\">\\n<!-- To view this file, download free mind mapping software FreeMind from http://freemind.sourceforge.net -->\\n';\n    if (rootNode) {\n        xmlString += \"\".concat(getNodeXML(rootNode), \"\\n\");\n    } else {\n        mindMap.forEach((node)=>{\n            if (!includedNodeIds.has(node.id)) {\n                xmlString += \"\".concat(getNodeXML(node), \"\\n\");\n            }\n        });\n    }\n    xmlString += \"</map>\";\n    return xmlString;\n};\nconst jsonToXMLSelectNode = (node)=>{\n    let backgroundColor = \"\";\n    if (node.type === \"Idea\") {\n        backgroundColor = \"#008000\"; // Green\n    } else if (node.type === \"Context\") {\n        backgroundColor = \"#808080\"; // Grey\n    } else if (node.type === \"Content\") {\n        backgroundColor = \"#FFFFFF\"; // White\n    }\n    return '<node ID=\"'.concat(node.id, '\" TEXT=\"').concat(node.topic, '\"').concat(node.isroot ? ' ROOT=\"true\"' : \"\", ' BACKGROUND_COLOR=\"').concat(backgroundColor, '\"></node>');\n};\nconst xmlToJson = (xmlString)=>{\n    const parser = new DOMParser();\n    const xmlDoc = parser.parseFromString(xmlString, \"application/xml\");\n    const nodes = [];\n    let isFirstNode = true;\n    const parseNode = (xmlNode, parentId)=>{\n        const id = parentId ? xmlNode.getAttribute(\"ID\") : \"root\";\n        const topic = xmlNode.getAttribute(\"TEXT\");\n        let type = determineNodeType(xmlNode.getAttribute(\"BACKGROUND_COLOR\"));\n        if (type === \"Unknown\") {\n            if (isFirstNode) {\n                type = \"default\";\n                isFirstNode = false;\n            } else {\n                type = \"Content\";\n            }\n        }\n        const node = {\n            id,\n            topic,\n            type,\n            parentid: parentId\n        };\n        if (!parentId) {\n            node.isroot = true;\n        }\n        nodes.push(node);\n        const childNodes = xmlNode.children;\n        for(let i = 0; i < childNodes.length; i++){\n            parseNode(childNodes[i], id);\n        }\n    };\n    const rootElement = xmlDoc.getElementsByTagName(\"node\")[0];\n    if (rootElement) {\n        parseNode(rootElement);\n    }\n    return nodes;\n};\n// Helper function to determine node type based on color\nconst determineNodeType = (color)=>{\n    switch(color){\n        case \"#008000\":\n            return \"Idea\";\n        case \"#808080\":\n            return \"Context\";\n        case \"#FFFFFF\":\n            return \"Content\";\n        default:\n            return \"Unknown\";\n    }\n};\nconst useMindMapStore = (0,zustand__WEBPACK_IMPORTED_MODULE_2__.create)((set)=>({\n        minds: [],\n        currentMind: null,\n        commandToExecute: null,\n        setCommandToExecute: (command)=>set({\n                commandToExecute: command\n            }),\n        setMinds: (newMinds)=>{\n            localStorage.setItem(\"mindMapData\", JSON.stringify(newMinds));\n            window.dispatchEvent(new Event(\"projectChanged\"));\n            set({\n                minds: newMinds\n            });\n        },\n        addNode: (parentNodeId, newNode)=>set((state)=>{\n                const mind = state.minds[0];\n                const parentNodeExists = mind.data.some((node)=>node.id === parentNodeId);\n                if (parentNodeExists) {\n                    const updatedMind = {\n                        ...mind,\n                        data: [\n                            ...mind.data,\n                            {\n                                ...newNode,\n                                parentid: parentNodeId\n                            }\n                        ]\n                    };\n                    const updatedMinds = state.minds.map((m, index)=>index === 0 ? updatedMind : m);\n                    localStorage.setItem(\"mindMapData\", JSON.stringify(updatedMinds));\n                    window.dispatchEvent(new Event(\"projectChanged\"));\n                    return {\n                        minds: updatedMinds\n                    };\n                } else {\n                    _barrel_optimize_names_message_notification_antd__WEBPACK_IMPORTED_MODULE_3__[\"default\"].error(\"Parent node not found\");\n                    return state;\n                }\n            }),\n        deleteNode: (nodeId)=>set((state)=>{\n                const deleteNodeAndChildren = (nodes, id)=>{\n                    const childrenIds = nodes.filter((node)=>node.parentid === id).map((node)=>node.id);\n                    let filteredNodes = nodes.filter((node)=>node.id !== id);\n                    childrenIds.forEach((childId)=>{\n                        filteredNodes = deleteNodeAndChildren(filteredNodes, childId);\n                    });\n                    return filteredNodes;\n                };\n                const updatedMinds = state.minds.map((mind)=>({\n                        ...mind,\n                        data: deleteNodeAndChildren(mind.data, nodeId)\n                    }));\n                localStorage.setItem(\"mindMapData\", JSON.stringify(updatedMinds));\n                window.dispatchEvent(new Event(\"projectChanged\"));\n                return {\n                    minds: updatedMinds\n                };\n            }),\n        initializeMindMap: ()=>{\n            const mindData = localStorage.getItem(\"mindMapData\");\n            if (!mindData || mindData.length === 2) {\n                localStorage.setItem(\"mindMapData\", JSON.stringify([\n                    defaultMindMap\n                ]));\n                window.dispatchEvent(new Event(\"projectChanged\"));\n                set({\n                    minds: [\n                        defaultMindMap\n                    ],\n                    currentMind: defaultMindMap\n                });\n            } else {\n                const parsedMinds = JSON.parse(mindData);\n                set({\n                    minds: parsedMinds,\n                    currentMind: parsedMinds[0]\n                });\n            }\n        },\n        createNewProject: (projectName)=>set((state)=>{\n                if (!projectName) {\n                    _barrel_optimize_names_message_notification_antd__WEBPACK_IMPORTED_MODULE_3__[\"default\"].error(\"Please input project name\");\n                    return {\n                        minds: state.minds\n                    };\n                }\n                // Retrieve existing projects from localStorage\n                const data = localStorage.getItem(\"mindMapData\");\n                let newProjectName = projectName;\n                if (data) {\n                    try {\n                        const parsedMinds = JSON.parse(data);\n                        // Check if the exact project name exists\n                        const exactProjectExists = parsedMinds.some((project)=>project.projectName === projectName);\n                        if (exactProjectExists) {\n                            // Filter the existing projects that start with the same base name\n                            let existingProjects = parsedMinds.filter((item)=>item.projectName.startsWith(projectName));\n                            // Collect suffixes for all matching projects (e.g., project1, project2, etc.)\n                            const suffixes = existingProjects.map((project)=>{\n                                const match = project.projectName.match(new RegExp(\"^\".concat(projectName, \" (\\\\d+)$\")));\n                                if (match) {\n                                    return parseInt(match[1], 10);\n                                }\n                                return null;\n                            }).filter((suffix)=>suffix !== null); // Remove non-numeric matches\n                            // Sort suffixes to identify gaps\n                            suffixes.sort((a, b)=>a - b);\n                            let newSuffix = 1; // Start from 1, as we are looking for 'project 1', 'project 2', etc.\n                            for(let i = 0; i < suffixes.length; i++){\n                                if (suffixes[i] === newSuffix) {\n                                    newSuffix++;\n                                } else {\n                                    break; // Found a gap, stop here\n                                }\n                            }\n                            // Set the new project name to 'project ' + newSuffix (e.g., 'project 1', 'project 2')\n                            newProjectName = projectName + \" \" + newSuffix;\n                        }\n                    } catch (error) {\n                        console.error(\"Failed to parse mind map data:\", error);\n                    }\n                }\n                // Create the new project with the updated project name\n                const newMindMap = {\n                    ...defaultMindMap,\n                    projectName: newProjectName,\n                    data: [\n                        {\n                            id: \"root\",\n                            isroot: true,\n                            topic: \"New MindMap\",\n                            type: \"root\"\n                        }\n                    ]\n                };\n                // Update the state and localStorage\n                const updatedMinds = [\n                    newMindMap,\n                    ...state.minds\n                ];\n                localStorage.setItem(\"mindMapData\", JSON.stringify(updatedMinds));\n                window.dispatchEvent(new Event(\"projectChanged\"));\n                return {\n                    minds: updatedMinds,\n                    currentMind: newMindMap\n                };\n            }),\n        getProjects: ()=>{\n            const data = localStorage.getItem(\"mindMapData\");\n            if (data) {\n                const parsedMinds = JSON.parse(data);\n                return parsedMinds.map((mind)=>mind.projectName);\n            }\n            return [];\n        },\n        setCurrentProject: (projectName)=>set((state)=>{\n                const selectedMind = state.minds.find((mind)=>mind.projectName === projectName);\n                if (selectedMind) {\n                    const updatedMinds = [\n                        selectedMind,\n                        ...state.minds.filter((mind)=>mind.projectName !== projectName)\n                    ];\n                    localStorage.setItem(\"mindMapData\", JSON.stringify(updatedMinds));\n                    window.dispatchEvent(new Event(\"projectChanged\"));\n                    return {\n                        minds: updatedMinds,\n                        currentMind: selectedMind\n                    };\n                }\n                return state;\n            }),\n        setMindMapProjectName: (projectName)=>{\n            const data = localStorage.getItem(\"mindMapData\");\n            if (data) {\n                try {\n                    const parsedMinds = JSON.parse(data);\n                    let newProjectName = projectName;\n                    // Check if the exact project name exists\n                    const exactProjectExists = parsedMinds.some((project)=>project.projectName === projectName);\n                    if (exactProjectExists) {\n                        // Filter the existing projects that start with the same base name\n                        let existingProjects = parsedMinds.filter((item)=>item.projectName.startsWith(projectName));\n                        // Collect suffixes for all matching projects (e.g., project1, project2, etc.)\n                        const suffixes = existingProjects.map((project)=>{\n                            const match = project.projectName.match(new RegExp(\"^\".concat(projectName, \" (\\\\d+)$\")));\n                            if (match) {\n                                return parseInt(match[1], 10);\n                            }\n                            return null;\n                        }).filter((suffix)=>suffix !== null); // Remove non-numeric matches\n                        // Sort suffixes to identify gaps\n                        suffixes.sort((a, b)=>a - b);\n                        let newSuffix = 1; // Start from 1, as we are looking for 'project 1', 'project 2', etc.\n                        for(let i = 0; i < suffixes.length; i++){\n                            if (suffixes[i] === newSuffix) {\n                                newSuffix++;\n                            } else {\n                                break; // Found a gap, stop here\n                            }\n                        }\n                        // Set the new project name to 'project ' + newSuffix (e.g., 'project 1', 'project 2')\n                        newProjectName = projectName + \" \" + newSuffix;\n                    }\n                    // Update the project name for the first item\n                    if (parsedMinds.length > 0) {\n                        parsedMinds[0].projectName = newProjectName;\n                        localStorage.setItem(\"mindMapData\", JSON.stringify(parsedMinds));\n                        window.dispatchEvent(new Event(\"projectChanged\"));\n                    }\n                } catch (error) {\n                    console.error(\"Failed to parse mind map data:\", error);\n                }\n            }\n        },\n        deleteMindMapProject: ()=>{\n            const data = localStorage.getItem(\"mindMapData\");\n            if (data) {\n                try {\n                    const parsedMinds = JSON.parse(data);\n                    if (parsedMinds.length > 0) {\n                        parsedMinds.shift();\n                        localStorage.setItem(\"mindMapData\", JSON.stringify(parsedMinds));\n                        window.dispatchEvent(new Event(\"projectChanged\"));\n                    }\n                } catch (error) {\n                    console.error(\"Failed to parse mind map data:\", error);\n                }\n            }\n        },\n        downloadFreemind: ()=>{\n            const data = localStorage.getItem(\"mindMapData\");\n            if (data) {\n                try {\n                    const parsedMinds = JSON.parse(data);\n                    const mindMapToDownload = parsedMinds[0].data; // Assuming you want to download the first mind map\n                    const xmlData = jsonToXML(mindMapToDownload);\n                    const blob = new Blob([\n                        xmlData\n                    ], {\n                        type: \"application/xml\"\n                    });\n                    const url = URL.createObjectURL(blob);\n                    const a = document.createElement(\"a\");\n                    a.href = url;\n                    a.download = \"\".concat(parsedMinds[0].projectName, \".mm\");\n                    document.body.appendChild(a);\n                    a.click();\n                    document.body.removeChild(a);\n                } catch (error) {\n                    console.error(\"Failed to parse mind map data:\", error);\n                }\n            }\n        },\n        downloadProject: ()=>{\n            const data = localStorage.getItem(\"mindMapData\");\n            if (data) {\n                try {\n                    const parsedMinds = JSON.parse(data);\n                    const mindMapToDownload = parsedMinds[0]; // Assuming you want to download the first mind map\n                    const blob = new Blob([\n                        JSON.stringify(mindMapToDownload)\n                    ], {\n                        type: \"application/json\"\n                    });\n                    const url = URL.createObjectURL(blob);\n                    const a = document.createElement(\"a\");\n                    a.href = url;\n                    a.download = \"\".concat(mindMapToDownload.projectName, \".json\");\n                    document.body.appendChild(a);\n                    a.click();\n                    document.body.removeChild(a);\n                } catch (error) {\n                    console.error(\"Failed to parse mind map data:\", error);\n                }\n            }\n        },\n        loadProject: async ()=>{\n            try {\n                const data = await (0,_utils_data__WEBPACK_IMPORTED_MODULE_0__.loadFromJSON)(); // Assuming loadFromJSON returns the loaded data as MindMap\n                (0,_utils_data__WEBPACK_IMPORTED_MODULE_0__.restoreData)(data);\n            } catch (error) {\n                console.error(\"Failed to load Freemind data:\", error);\n            }\n            return false;\n        },\n        loadFreeMind: async ()=>{\n            try {\n                const file = await (0,_utils_data__WEBPACK_IMPORTED_MODULE_0__.loadFromMM)();\n                const fileReader = new FileReader();\n                fileReader.onload = ()=>{\n                    const xmlString = fileReader.result;\n                    const jsonData = xmlToJson(xmlString);\n                    const storageData = localStorage.getItem(\"mindMapData\");\n                    if (storageData) {\n                        const mindData = JSON.parse(storageData);\n                        const newMindMap = {\n                            meta: {\n                                name: \"MindMap\",\n                                version: \"0.2\"\n                            },\n                            format: \"node_array\",\n                            projectName: \"New Freemind \".concat(new Date().getTime()),\n                            data: jsonData,\n                            RequestInstruction: \"\",\n                            configuration: {\n                                openAIKey: \"\",\n                                defaultAssistantId: \"\",\n                                defaultThreadId: \"\",\n                                commands: []\n                            }\n                        };\n                        mindData.unshift(newMindMap);\n                        localStorage.setItem(\"mindMapData\", JSON.stringify(mindData));\n                        window.dispatchEvent(new Event(\"projectChanged\"));\n                    }\n                };\n                fileReader.readAsText(file);\n                return true;\n            } catch (error) {\n                console.error(error);\n            }\n            return false;\n        },\n        setRequestContent: (value)=>{\n            const data = localStorage.getItem(\"mindMapData\");\n            if (data) {\n                const mindData = JSON.parse(data);\n                mindData[0].RequestInstruction = value;\n                localStorage.setItem(\"mindMapData\", JSON.stringify(mindData));\n            }\n        },\n        getDatas: ()=>{\n            const data = localStorage.getItem(\"mindMapData\");\n            if (data) {\n                return JSON.parse(data);\n            } else {\n                return [];\n            }\n        },\n        saveConfigurationDefaultValue: (openAIKey, defaultAssistantId, defaultThreadId)=>{\n            const data = localStorage.getItem(\"mindMapData\");\n            if (data) {\n                const mindData = JSON.parse(data);\n                mindData[0].configuration.openAIKey = openAIKey;\n                mindData[0].configuration.defaultAssistantId = defaultAssistantId;\n                mindData[0].configuration.defaultThreadId = defaultThreadId;\n                localStorage.setItem(\"mindMapData\", JSON.stringify(mindData));\n                window.dispatchEvent(new Event(\"projectChanged\"));\n            }\n        },\n        addCommand: ()=>{\n            let idea = [\n                0,\n                0\n            ];\n            let content = [\n                0,\n                0\n            ];\n            let context = [\n                0,\n                0\n            ];\n            const command = {\n                commandName: \"\",\n                assistantId: \"\",\n                threadId: \"\",\n                select: \"\",\n                idea: idea,\n                content: content,\n                context: context,\n                commands: \"\",\n                commandKey: new Date().toString()\n            };\n            const storageData = localStorage.getItem(\"mindMapData\");\n            if (storageData) {\n                const data = JSON.parse(storageData);\n                data[0].configuration.commands.push(command);\n                localStorage.setItem(\"mindMapData\", JSON.stringify(data));\n                window.dispatchEvent(new Event(\"projectChanged\"));\n            }\n        },\n        deleteCommand: (index)=>{\n            const storageData = localStorage.getItem(\"mindMapData\");\n            if (storageData) {\n                const data = JSON.parse(storageData);\n                if (data.length > 0) {\n                    data[0].configuration.commands.splice(index, 1);\n                    localStorage.setItem(\"mindMapData\", JSON.stringify(data));\n                    window.dispatchEvent(new Event(\"projectChanged\"));\n                }\n            }\n        },\n        saveCommand: (commandName, assistantId, threadId, select, idea, context, content, commands, id)=>{\n            const storageData = localStorage.getItem(\"mindMapData\");\n            if (storageData) {\n                const data = JSON.parse(storageData);\n                const command = {\n                    commandName,\n                    assistantId,\n                    threadId,\n                    select,\n                    idea: idea,\n                    content: content,\n                    context: context,\n                    commands,\n                    commandKey: new Date().toString()\n                };\n                data[0].configuration.commands[id] = command;\n                localStorage.setItem(\"mindMapData\", JSON.stringify(data));\n                window.dispatchEvent(new Event(\"projectChanged\"));\n            }\n        },\n        getCommand: (index)=>{\n            const mindMapData = localStorage.getItem(\"mindMapData\");\n            if (mindMapData) {\n                const data = JSON.parse(mindMapData);\n                if (data[0].configuration.commands[0]) {\n                    let commandData;\n                    commandData = data[0].configuration.commands[index];\n                    const command = {\n                        commandName: commandData.commandName,\n                        assistantId: commandData.assistantId,\n                        threadId: commandData.threadId,\n                        select: commandData.select,\n                        commands: commandData.commands,\n                        idea: commandData.idea,\n                        context: commandData.context,\n                        content: commandData.content,\n                        commandKey: new Date().toString()\n                    };\n                    return command;\n                } else {\n                    return defaultReturnCommand;\n                }\n            }\n            return defaultReturnCommand;\n        },\n        getCommands: ()=>{\n            const mindMapData = localStorage.getItem(\"mindMapData\");\n            if (mindMapData) {\n                const data = JSON.parse(mindMapData);\n                return data[0].configuration.commands;\n            }\n        },\n        saveCommandReorder: (commands)=>{\n            const mindData = localStorage.getItem(\"mindMapData\");\n            if (mindData) {\n                const data = JSON.parse(mindData);\n                if (data) {\n                    data[0].configuration.commands = commands;\n                    localStorage.setItem(\"mindMapData\", JSON.stringify(data));\n                    window.dispatchEvent(new Event(\"projectChanged\"));\n                }\n            }\n        },\n        updateNodeContent: (nodeId, newContent)=>{\n            const mindMapData = localStorage.getItem(\"mindMapData\");\n            if (mindMapData) {\n                const data = JSON.parse(mindMapData);\n                data[0].data.map((item)=>{\n                    if (item.id === nodeId) {\n                        item.topic = newContent;\n                    }\n                });\n                localStorage.setItem(\"mindMapData\", JSON.stringify(data));\n                window.dispatchEvent(new Event(\"projectChanged\"));\n            }\n        },\n        getDefaultThreadId: ()=>{\n            const mindMapData = localStorage.getItem(\"mindMapData\");\n            if (mindMapData) {\n                const data = JSON.parse(mindMapData);\n                return data[0].configuration.defaultThreadId;\n            }\n        },\n        getOpenAIKey: ()=>{\n            const mindMapData = localStorage.getItem(\"mindMapData\");\n            if (mindMapData) {\n                const data = JSON.parse(mindMapData);\n                return data[0].configuration.openAIKey;\n            }\n        },\n        getDefaultAssistantId: ()=>{\n            const mindMapData = localStorage.getItem(\"mindMapData\");\n            if (mindMapData) {\n                const data = JSON.parse(mindMapData);\n                return data[0].configuration.defaultAssistantId;\n            }\n        },\n        getConfiguration: ()=>{\n            const mindMapData = localStorage.getItem(\"mindMapData\");\n            if (mindMapData) {\n                const data = JSON.parse(mindMapData);\n                return data[0].configuration;\n            }\n        },\n        executeCommand: async (key, parentId, node, nodeType, cancelToken)=>{\n            const mindMapData = localStorage.getItem(\"mindMapData\");\n            if (mindMapData) {\n                const data = JSON.parse(mindMapData);\n                const openAIKey = data[0].configuration.openAIKey;\n                const defaultAssistantId = data[0].configuration.defaultAssistantId;\n                const defaultThreadId = data[0].configuration.defaultThreadId;\n                const requestInstruction = data[0].RequestInstruction;\n                try {\n                    const currentCommand = data[0].configuration.commands[key];\n                    let ideaHeadLevel, ideaDepth, contextHeadLevel, contextDepth, contentHeadLevel, contentDepth;\n                    ideaHeadLevel = currentCommand.idea[0];\n                    ideaDepth = currentCommand.idea[1] - 1;\n                    contextHeadLevel = currentCommand.context[0];\n                    contextDepth = currentCommand.context[1] - 1;\n                    contentHeadLevel = currentCommand.content[0];\n                    contentDepth = currentCommand.content[1] - 1;\n                    console.log(ideaHeadLevel, contextHeadLevel, contentHeadLevel);\n                    let promptNodes = [];\n                    if (node.id === \"root\") {\n                        promptNodes.push(createNodeData(node));\n                    } else {\n                        const findRootNode = (currentNode, level)=>{\n                            let rootNode = currentNode;\n                            while(level){\n                                if (rootNode.data.type == \"root\" && level > 0) {\n                                    return;\n                                } else {\n                                    rootNode = rootNode.parent;\n                                }\n                                level = level - 1;\n                            }\n                            return rootNode;\n                        };\n                        const getNodesWithinDepth = function(node, maxDepth, nodeType) {\n                            let currentDepth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;\n                            if (node == undefined) {\n                                return [];\n                            }\n                            if (currentDepth >= maxDepth) {\n                                return [];\n                            }\n                            let nodes = [];\n                            if (node.children && node.children.length > 0) {\n                                node.children.forEach((child)=>{\n                                    if (child.data.type === nodeType) {\n                                        nodes.push(child);\n                                    }\n                                    nodes = nodes.concat(getNodesWithinDepth(child, maxDepth, nodeType, currentDepth + 1));\n                                });\n                            }\n                            return nodes;\n                        };\n                        const removeDuplicates = (data)=>{\n                            const seenIds = new Set();\n                            return data.filter((item)=>{\n                                if (seenIds.has(item.id)) {\n                                    return false; // Duplicate found, skip it\n                                } else {\n                                    seenIds.add(item.id);\n                                    return true; // Not a duplicate, keep it\n                                }\n                            });\n                        };\n                        const ideaRootNode = findRootNode(node, ideaHeadLevel);\n                        const contextRootNode = findRootNode(node, contextHeadLevel);\n                        const contentRootNode = findRootNode(node, contentHeadLevel);\n                        console.log(ideaRootNode, contextRootNode, contentRootNode);\n                        if (!ideaRootNode || !contextRootNode || !contentRootNode) {\n                            const nodeType = !ideaRootNode ? \"Ideas\" : !contextRootNode ? \"Context\" : \"Content\";\n                            _barrel_optimize_names_message_notification_antd__WEBPACK_IMPORTED_MODULE_4__[\"default\"].error({\n                                message: \"Please check \".concat(nodeType, \"'s Head Levels. This value is too big for selected node.\")\n                            });\n                            window.dispatchEvent(new Event(\"projectChanged\"));\n                            const event = new CustomEvent(\"threadIdUpdated\", {\n                                detail: {\n                                    key\n                                }\n                            });\n                            window.dispatchEvent(event);\n                            return;\n                        }\n                        promptNodes = [\n                            ...promptNodes,\n                            ...getNodesWithinDepth(ideaRootNode, ideaDepth, \"Idea\") || []\n                        ];\n                        promptNodes = [\n                            ...promptNodes,\n                            ...getNodesWithinDepth(contextRootNode, contextDepth, \"Context\") || []\n                        ];\n                        promptNodes = [\n                            ...promptNodes,\n                            ...getNodesWithinDepth(contentRootNode, contentDepth, \"Content\") || []\n                        ];\n                        if (ideaRootNode) {\n                            promptNodes.unshift(ideaRootNode);\n                        }\n                        if (contextRootNode) {\n                            promptNodes.unshift(contextRootNode);\n                        }\n                        if (contentRootNode) {\n                            promptNodes.unshift(contentRootNode);\n                        }\n                        promptNodes = [\n                            ...removeDuplicates(promptNodes)\n                        ];\n                        console.log(promptNodes);\n                    }\n                    promptNodes.sort((a, b)=>{\n                        // Extract numeric part after '#' in id\n                        const idA = parseInt(a.id.split(\"#\")[1], 10);\n                        const idB = parseInt(b.id.split(\"#\")[1], 10);\n                        // Compare the numeric parts\n                        return idA - idB;\n                    });\n                    console.log(promptNodes, \"This is mindmap array data and it is include selected node and parent or brother nodes if they are seleted.\");\n                    const xmlData = jsonToXMLFiltering(promptNodes);\n                    console.log(xmlData, \"This is mindmap xml data and it is include selected node and parent or brother nodes if they are seleted.\");\n                    const selectNodeXmlData = jsonToXMLSelectNode(node);\n                    const response = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(\"/api/commandOpenai\", {\n                        openAIKey: openAIKey,\n                        defaultAssistantId: currentCommand.assistantId == \"\" ? defaultAssistantId : currentCommand.assistantId,\n                        prompt: currentCommand.commands,\n                        threadId: currentCommand.threadId == \"\" ? defaultThreadId : currentCommand.threadId,\n                        nodes: xmlData,\n                        selectNode: selectNodeXmlData,\n                        general_prompt: requestInstruction\n                    }, {\n                        cancelToken: cancelToken\n                    });\n                    const content = response.data.message.content;\n                    const type = nodeType;\n                    if (nodeType != \"Edit Node\") {\n                        if (Array.isArray(content)) {\n                            const threadId = data[0].configuration.defaultThreadId;\n                            let count = 0;\n                            content.forEach((value)=>{\n                                let node = {\n                                    id: \"\".concat(type, \"_#\").concat(new Date().getTime() + count),\n                                    parentid: parentId,\n                                    isroot: false,\n                                    topic: value,\n                                    type: type\n                                };\n                                data[0].data.push(node);\n                                count++;\n                            });\n                            if (currentCommand.threadId === \"\") {\n                                currentCommand.threadId = threadId;\n                                localStorage.setItem(\"mindMapData\", JSON.stringify(data));\n                                window.dispatchEvent(new Event(\"projectChanged\"));\n                                const event = new CustomEvent(\"threadIdUpdated\", {\n                                    detail: {\n                                        key\n                                    }\n                                });\n                                window.dispatchEvent(event);\n                            } else {\n                                localStorage.setItem(\"mindMapData\", JSON.stringify(data));\n                                window.dispatchEvent(new Event(\"projectChanged\"));\n                                const event = new CustomEvent(\"threadIdUpdated\", {\n                                    detail: {\n                                        key\n                                    }\n                                });\n                                window.dispatchEvent(event);\n                            }\n                        } else {\n                            const threadId = data[0].configuration.defaultThreadId;\n                            let count = 0;\n                            let node = {\n                                id: \"\".concat(type, \"_#\").concat(new Date().getTime() + count),\n                                parentid: parentId,\n                                isroot: false,\n                                topic: content,\n                                type: type\n                            };\n                            data[0].data.push(node);\n                            count++;\n                            if (currentCommand.threadId === \"\") {\n                                currentCommand.threadId = threadId;\n                                localStorage.setItem(\"mindMapData\", JSON.stringify(data));\n                                window.dispatchEvent(new Event(\"projectChanged\"));\n                                const event = new CustomEvent(\"threadIdUpdated\", {\n                                    detail: {\n                                        key\n                                    }\n                                });\n                                window.dispatchEvent(event);\n                            } else {\n                                localStorage.setItem(\"mindMapData\", JSON.stringify(data));\n                                window.dispatchEvent(new Event(\"projectChanged\"));\n                                const event = new CustomEvent(\"threadIdUpdated\", {\n                                    detail: {\n                                        key\n                                    }\n                                });\n                                window.dispatchEvent(event);\n                            }\n                        }\n                    } else {\n                        if (Array.isArray(content)) {\n                            const threadId = data[0].configuration.defaultThreadId;\n                            data[0].data.forEach((element)=>{\n                                if (element.id === node.id) {\n                                    element.topic = content[0];\n                                }\n                            });\n                            if (currentCommand.threadId === \"\") {\n                                currentCommand.threadId = threadId;\n                                localStorage.setItem(\"mindMapData\", JSON.stringify(data));\n                            } else {\n                                localStorage.setItem(\"mindMapData\", JSON.stringify(data));\n                            }\n                            window.dispatchEvent(new Event(\"projectChanged\"));\n                            const event = new CustomEvent(\"threadIdUpdated\", {\n                                detail: {\n                                    key\n                                }\n                            });\n                            window.dispatchEvent(event);\n                        } else {\n                            throw new Error(\"Invalid message content\");\n                        }\n                    }\n                } catch (error) {\n                    if (axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isCancel(error)) {} else {\n                        if (error.response.status) {\n                            const errorStatus = error.response.status;\n                            const event = new CustomEvent(\"errorOccurs\", {\n                                detail: {\n                                    errorStatus\n                                }\n                            });\n                            window.dispatchEvent(event);\n                        }\n                    }\n                }\n            }\n        }\n    }));\n/* harmony default export */ __webpack_exports__[\"default\"] = (useMindMapStore);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZXMvbWFwU3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZDO0FBQ1o7QUFDUDtBQVEyQztBQUVyRSxNQUFNTyxjQUFjSiw2Q0FBS0EsQ0FBQ0ssV0FBVztBQUNyQyxJQUFJQztBQUVKLE1BQU1DLHVCQUFzQztJQUMxQ0MsYUFBYTtJQUNiQyxhQUFhO0lBQ2JDLFVBQVU7SUFDVkMsVUFBVTtJQUNWQyxRQUFRO0lBQ1JDLE1BQU07UUFBQztRQUFHO0tBQUU7SUFDWkMsU0FBUztRQUFDO1FBQUc7S0FBRTtJQUNmQyxTQUFTO1FBQUM7UUFBRztLQUFFO0lBQ2ZDLFlBQVksSUFBSUMsT0FBT0MsUUFBUTtBQUNqQztBQXlEQSxNQUFNQyxpQkFBMEI7SUFDOUJDLE1BQU07UUFDSkMsTUFBTTtRQUNOQyxTQUFTO0lBQ1g7SUFDQUMsUUFBUTtJQUNSQyxhQUFhO0lBQ2JDLE1BQU07UUFBQztZQUFFQyxJQUFJO1lBQVFDLFFBQVE7WUFBTUMsT0FBTztZQUFXQyxNQUFNO1FBQU87S0FBRTtJQUNwRUMsb0JBQW9CO0lBQ3BCQyxlQUFlO1FBQ2JDLFdBQVc7UUFDWEMsb0JBQW9CO1FBQ3BCQyxpQkFBaUI7UUFDakJ2QixVQUFVLEVBQUU7SUFDZDtBQUNGO0FBRUEsTUFBTXdCLGlCQUFpQixDQUFDQztJQUN0QixPQUFPO1FBQ0xWLElBQUlVLEtBQUtWLEVBQUU7UUFDWFcsVUFBVUQsS0FBS0UsTUFBTSxHQUFHRixLQUFLRSxNQUFNLENBQUNaLEVBQUUsR0FBR2E7UUFDekNaLFFBQVFTLEtBQUtFLE1BQU0sR0FBRyxRQUFRO1FBQzlCVixPQUFPUSxLQUFLUixLQUFLO1FBQ2pCQyxNQUFNTyxLQUFLWCxJQUFJLENBQUNJLElBQUk7SUFDdEI7QUFDRjtBQUVBLE1BQU1XLFlBQVksQ0FBQ0M7SUFDakIsTUFBTUMsa0JBQWtCLElBQUlDO0lBRTVCLE1BQU1DLGFBQWEsQ0FBQ1I7UUFDbEIsSUFBSVMsa0JBQWtCO1FBRXRCLElB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Q0FBQytLO2dDQUNwQixJQUFJQSxRQUFRN00sRUFBRSxLQUFLVSxLQUFLVixFQUFFLEVBQUU7b0NBQzFCNk0sUUFBUTNNLEtBQUssR0FBR2IsT0FBTyxDQUFDLEVBQUU7Z0NBQzVCOzRCQUNGOzRCQUVBLElBQUltTCxlQUFleEwsUUFBUSxLQUFLLElBQUk7Z0NBQ2xDd0wsZUFBZXhMLFFBQVEsR0FBR0E7Z0NBQzFCOEUsYUFBYUMsT0FBTyxDQUFDLGVBQWVDLEtBQUtDLFNBQVMsQ0FBQ2xFOzRCQUNyRCxPQUFPO2dDQUNMK0QsYUFBYUMsT0FBTyxDQUFDLGVBQWVDLEtBQUtDLFNBQVMsQ0FBQ2xFOzRCQUNyRDs0QkFFQW1FLE9BQU9DLGFBQWEsQ0FBQyxJQUFJQyxNQUFNOzRCQUUvQixNQUFNMEgsUUFBUSxJQUFJQyxZQUFZLG1CQUFtQjtnQ0FDL0NDLFFBQVE7b0NBQUUzQjtnQ0FBSTs0QkFDaEI7NEJBQ0FuRyxPQUFPQyxhQUFhLENBQUMySDt3QkFDdkIsT0FBTzs0QkFDTCxNQUFNLElBQUlnQixNQUFNO3dCQUNsQjtvQkFDRjtnQkFDRixFQUFFLE9BQU85SCxPQUFZO29CQUNuQixJQUFJMUcsNkNBQUtBLENBQUN5TyxRQUFRLENBQUMvSCxRQUFRLENBQzNCLE9BQU87d0JBQ0wsSUFBSUEsTUFBTXFILFFBQVEsQ0FBQ1csTUFBTSxFQUFFOzRCQUN6QixNQUFNQyxjQUFjakksTUFBTXFILFFBQVEsQ0FBQ1csTUFBTTs0QkFDekMsTUFBTWxCLFFBQVEsSUFBSUMsWUFBWSxlQUFlO2dDQUMzQ0MsUUFBUTtvQ0FBRWlCO2dDQUFZOzRCQUN4Qjs0QkFDQS9JLE9BQU9DLGFBQWEsQ0FBQzJIO3dCQUN2QjtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtBQUVBLCtEQUFlekksZUFBZUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3RvcmVzL21hcFN0b3JlLnRzPzI4OGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWVzc2FnZSwgbm90aWZpY2F0aW9uIH0gZnJvbSBcImFudGRcIjtcclxuaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSBcInp1c3RhbmRcIjtcclxuaW1wb3J0IGF4aW9zIGZyb20gXCJheGlvc1wiO1xyXG5pbXBvcnQge1xyXG4gIE5vZGUsXHJcbiAgQ29tbWFuZHMsXHJcbiAgUmV0dXJuQ29tbWFuZCxcclxuICBtaW5kTWFwLFxyXG4gIGNvbmZpZ3VyYXRpb24sXHJcbn0gZnJvbSBcIkAvdXRpbHMvdHlwZVwiO1xyXG5pbXBvcnQgeyBsb2FkRnJvbUpTT04sIGxvYWRGcm9tTU0sIHJlc3RvcmVEYXRhIH0gZnJvbSBcIkAvdXRpbHMvZGF0YVwiO1xyXG5cclxuY29uc3QgY2FuY2VsVG9rZW4gPSBheGlvcy5DYW5jZWxUb2tlbjtcclxubGV0IGNhbmNlbDtcclxuXHJcbmNvbnN0IGRlZmF1bHRSZXR1cm5Db21tYW5kOiBSZXR1cm5Db21tYW5kID0ge1xyXG4gIGNvbW1hbmROYW1lOiBcIlwiLFxyXG4gIGFzc2lzdGFudElkOiBcIlwiLFxyXG4gIHRocmVhZElkOiBcIlwiLFxyXG4gIGNvbW1hbmRzOiBcIlwiLFxyXG4gIHNlbGVjdDogXCJcIixcclxuICBpZGVhOiBbMCwgMF0sXHJcbiAgY29udGV4dDogWzAsIDBdLFxyXG4gIGNvbnRlbnQ6IFswLCAwXSxcclxuICBjb21tYW5kS2V5OiBuZXcgRGF0ZSgpLnRvU3RyaW5nKCksXHJcbn07XHJcblxyXG5pbnRlcmZhY2UgTWluZE1hcFN0YXRlIHtcclxuICBtaW5kczogbWluZE1hcFtdO1xyXG4gIGN1cnJlbnRNaW5kOiBtaW5kTWFwIHwgbnVsbDtcclxuICBjb21tYW5kVG9FeGVjdXRlOiBDb21tYW5kcyB8IG51bGw7XHJcbiAgc2V0TWluZHM6IChuZXdNaW5kczogbWluZE1hcFtdKSA9PiB2b2lkO1xyXG4gIGFkZE5vZGU6IChwYXJlbnROb2RlSWQ6IHN0cmluZywgbmV3Tm9kZTogTm9kZSkgPT4gdm9pZDtcclxuICBkZWxldGVOb2RlOiAobm9kZUlkOiBzdHJpbmcpID0+IHZvaWQ7XHJcbiAgaW5pdGlhbGl6ZU1pbmRNYXA6ICgpID0+IHZvaWQ7XHJcbiAgY3JlYXRlTmV3UHJvamVjdDogKHByb2plY3ROYW1lOiBzdHJpbmcpID0+IHZvaWQ7XHJcbiAgZ2V0UHJvamVjdHM6ICgpID0+IHN0cmluZ1tdO1xyXG4gIHNldEN1cnJlbnRQcm9qZWN0OiAocHJvamVjdE5hbWU6IHN0cmluZykgPT4gdm9pZDtcclxuICBzZXRNaW5kTWFwUHJvamVjdE5hbWU6IChwcm9qZWN0TmFtZTogc3RyaW5nKSA9PiB2b2lkO1xyXG4gIGRlbGV0ZU1pbmRNYXBQcm9qZWN0OiAoKSA9PiB2b2lkO1xyXG4gIGRvd25sb2FkRnJlZW1pbmQ6ICgpID0+IHZvaWQ7XHJcbiAgZG93bmxvYWRQcm9qZWN0OiAoKSA9PiB2b2lkO1xyXG4gIGxvYWRQcm9qZWN0OiAoKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xyXG4gIGxvYWRGcmVlTWluZDogKCkgPT4gUHJvbWlzZTxib29sZWFuPjtcclxuICBzZXRSZXF1ZXN0Q29udGVudDogKHZhbHVlOiBzdHJpbmcpID0+IHZvaWQ7XHJcbiAgZ2V0RGF0YXM6ICgpID0+IG1pbmRNYXBbXTtcclxuICBzYXZlQ29uZmlndXJhdGlvbkRlZmF1bHRWYWx1ZTogKFxyXG4gICAgb3BlbkFJS2V5OiBzdHJpbmcsXHJcbiAgICBkZWZhdWx0QXNzaXN0YW50SWQ6IHN0cmluZyxcclxuICAgIGRlZmF1bHRUaHJlYWRJZDogc3RyaW5nXHJcbiAgKSA9PiB2b2lkO1xyXG4gIGFkZENvbW1hbmQ6ICgpID0+IHZvaWQ7XHJcbiAgZGVsZXRlQ29tbWFuZDogKGluZGV4OiBudW1iZXIpID0+IHZvaWQ7XHJcbiAgc2F2ZUNvbW1hbmQ6IChcclxuICAgIGNvbW1hbmROYW1lOiBzdHJpbmcsXHJcbiAgICBhc3Npc3RhbnRJZDogc3RyaW5nLFxyXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcclxuICAgIHNlbGVjdDogc3RyaW5nLFxyXG4gICAgaWRlYXM6IG51bWJlcltdLFxyXG4gICAgY29udGV4dDogbnVtYmVyW10sXHJcbiAgICBjb250ZW50OiBudW1iZXJbXSxcclxuICAgIGNvbW1hbmRzOiBzdHJpbmcsXHJcbiAgICBpZDogbnVtYmVyXHJcbiAgKSA9PiB2b2lkO1xyXG4gIGdldENvbW1hbmQ6IChpbmRleDogbnVtYmVyKSA9PiBSZXR1cm5Db21tYW5kO1xyXG4gIGdldENvbW1hbmRzOiAoKSA9PiBDb21tYW5kc1tdO1xyXG4gIHNhdmVDb21tYW5kUmVvcmRlcjogKGNvbW1hbmRzOiBDb21tYW5kc1tdKSA9PiB2b2lkO1xyXG4gIHVwZGF0ZU5vZGVDb250ZW50OiAobm9kZUlkOiBzdHJpbmcsIG5ld0NvbnRlbnQ6IHN0cmluZykgPT4gdm9pZDtcclxuICBnZXREZWZhdWx0VGhyZWFkSWQ6ICgpID0+IHN0cmluZztcclxuICBnZXREZWZhdWx0QXNzaXN0YW50SWQ6ICgpID0+IHN0cmluZztcclxuICBnZXRPcGVuQUlLZXk6ICgpID0+IHN0cmluZztcclxuICBnZXRDb25maWd1cmF0aW9uOiAoKSA9PiBjb25maWd1cmF0aW9uO1xyXG4gIGV4ZWN1dGVDb21tYW5kOiAoXHJcbiAgICBrZXk6IG51bWJlcixcclxuICAgIHBhcmVudElkOiBzdHJpbmcsXHJcbiAgICBub2RlOiBhbnksXHJcbiAgICBub2RlVHlwZTogc3RyaW5nLFxyXG4gICAgY2FuY2VsVG9rZW46IGFueVxyXG4gICkgPT4gdm9pZDtcclxuICBzZXRDb21tYW5kVG9FeGVjdXRlOiAoY29tbWFuZDogQ29tbWFuZHMgfCBudWxsKSA9PiB2b2lkO1xyXG59XHJcblxyXG5jb25zdCBkZWZhdWx0TWluZE1hcDogbWluZE1hcCA9IHtcclxuICBtZXRhOiB7XHJcbiAgICBuYW1lOiBcIk1pbmRNYXBcIixcclxuICAgIHZlcnNpb246IFwiMC4yXCIsXHJcbiAgfSxcclxuICBmb3JtYXQ6IFwibm9kZV9hcnJheVwiLFxyXG4gIHByb2plY3ROYW1lOiBcIkRlZmF1bHQgUHJvamVjdFwiLFxyXG4gIGRhdGE6IFt7IGlkOiBcInJvb3RcIiwgaXNyb290OiB0cnVlLCB0b3BpYzogXCJNaW5kTWFwXCIsIHR5cGU6IFwicm9vdFwiIH1dLFxyXG4gIFJlcXVlc3RJbnN0cnVjdGlvbjogXCJcIixcclxuICBjb25maWd1cmF0aW9uOiB7XHJcbiAgICBvcGVuQUlLZXk6IFwiXCIsXHJcbiAgICBkZWZhdWx0QXNzaXN0YW50SWQ6IFwiXCIsXHJcbiAgICBkZWZhdWx0VGhyZWFkSWQ6IFwiXCIsXHJcbiAgICBjb21tYW5kczogW10sXHJcbiAgfSxcclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZU5vZGVEYXRhID0gKG5vZGU6IGFueSkgPT4ge1xyXG4gIHJldHVybiB7XHJcbiAgICBpZDogbm9kZS5pZCxcclxuICAgIHBhcmVudGlkOiBub2RlLnBhcmVudCA/IG5vZGUucGFyZW50LmlkIDogdW5kZWZpbmVkLFxyXG4gICAgaXNyb290OiBub2RlLnBhcmVudCA/IGZhbHNlIDogdHJ1ZSxcclxuICAgIHRvcGljOiBub2RlLnRvcGljLFxyXG4gICAgdHlwZTogbm9kZS5kYXRhLnR5cGUsXHJcbiAgfTtcclxufTtcclxuXHJcbmNvbnN0IGpzb25Ub1hNTCA9IChtaW5kTWFwOiBOb2RlW10pOiBzdHJpbmcgPT4ge1xyXG4gIGNvbnN0IGluY2x1ZGVkTm9kZUlkcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG5cclxuICBjb25zdCBnZXROb2RlWE1MID0gKG5vZGU6IE5vZGUpOiBzdHJpbmcgPT4ge1xyXG4gICAgbGV0IGJhY2tncm91bmRDb2xvciA9IFwiXCI7XHJcblxyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJJZGVhXCIpIHtcclxuICAgICAgYmFja2dyb3VuZENvbG9yID0gXCIjMDA4MDAwXCI7IC8vIEdyZWVuXHJcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJDb250ZXh0XCIpIHtcclxuICAgICAgYmFja2dyb3VuZENvbG9yID0gXCIjODA4MDgwXCI7IC8vIEdyZXlcclxuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIkNvbnRlbnRcIikge1xyXG4gICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBcIiNGRkZGRkZcIjsgLy8gV2hpdGVcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IG1pbmRNYXAuZmlsdGVyKChuKSA9PiBuLnBhcmVudGlkID09PSBub2RlLmlkKTtcclxuXHJcbiAgICBjb25zdCBjaGlsZHJlblhNTCA9IGNoaWxkcmVuLm1hcChnZXROb2RlWE1MKS5qb2luKFwiXCIpO1xyXG4gICAgaW5jbHVkZWROb2RlSWRzLmFkZChub2RlLmlkKTtcclxuXHJcbiAgICByZXR1cm4gYDxub2RlIElEPVwiJHtub2RlLmlkfVwiIFRFWFQ9XCIke25vZGUudG9waWN9XCIke25vZGUuaXNyb290ID8gJyBST09UPVwidHJ1ZVwiJyA6IFwiXCJcclxuICAgICAgfSBCQUNLR1JPVU5EX0NPTE9SPVwiJHtiYWNrZ3JvdW5kQ29sb3J9XCI+JHtjaGlsZHJlblhNTH08L25vZGU+YDtcclxuICB9O1xyXG5cclxuICBjb25zdCByb290Tm9kZSA9IG1pbmRNYXAuZmluZCgobikgPT4gbi5pc3Jvb3QpIHx8IG1pbmRNYXBbMF07XHJcbiAgbGV0IHhtbFN0cmluZyA9IGA8bWFwIHZlcnNpb249XCIxLjAuMVwiPlxcbjwhLS0gVG8gdmlldyB0aGlzIGZpbGUsIGRvd25sb2FkIGZyZWUgbWluZCBtYXBwaW5nIHNvZnR3YXJlIEZyZWVNaW5kIGZyb20gaHR0cDovL2ZyZWVtaW5kLnNvdXJjZWZvcmdlLm5ldCAtLT5cXG5gO1xyXG5cclxuICBpZiAocm9vdE5vZGUpIHtcclxuICAgIHhtbFN0cmluZyArPSBgJHtnZXROb2RlWE1MKHJvb3ROb2RlKX1cXG5gO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBtaW5kTWFwLmZvckVhY2goKG5vZGUpID0+IHtcclxuICAgICAgaWYgKCFpbmNsdWRlZE5vZGVJZHMuaGFzKG5vZGUuaWQpKSB7XHJcbiAgICAgICAgeG1sU3RyaW5nICs9IGAke2dldE5vZGVYTUwobm9kZSl9XFxuYDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICB4bWxTdHJpbmcgKz0gYDwvbWFwPmA7XHJcbiAgcmV0dXJuIHhtbFN0cmluZztcclxufTtcclxuXHJcbmNvbnN0IGpzb25Ub1hNTEZpbHRlcmluZyA9IChtaW5kTWFwOiBhbnlbXSk6IHN0cmluZyA9PiB7XHJcbiAgY29uc3QgaW5jbHVkZWROb2RlSWRzID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcblxyXG4gIGNvbnN0IGdldE5vZGVYTUwgPSAobm9kZTogYW55KTogc3RyaW5nID0+IHtcclxuICAgIGxldCBiYWNrZ3JvdW5kQ29sb3IgPSBcIlwiO1xyXG5cclxuICAgIGlmIChub2RlLmRhdGEudHlwZSA9PT0gXCJJZGVhXCIpIHtcclxuICAgICAgYmFja2dyb3VuZENvbG9yID0gXCIjMDA4MDAwXCI7IC8vIEdyZWVuXHJcbiAgICB9IGVsc2UgaWYgKG5vZGUuZGF0YS50eXBlID09PSBcIkNvbnRleHRcIikge1xyXG4gICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBcIiM4MDgwODBcIjsgLy8gR3JleVxyXG4gICAgfSBlbHNlIGlmIChub2RlLmRhdGEudHlwZSA9PT0gXCJDb250ZW50XCIpIHtcclxuICAgICAgYmFja2dyb3VuZENvbG9yID0gXCIjRkZGRkZGXCI7IC8vIFdoaXRlXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2hpbGRyZW4gPSBtaW5kTWFwLmZpbHRlcigobikgPT4gbi5wYXJlbnQ/LmlkID09PSBub2RlLmlkKTtcclxuXHJcbiAgICBjb25zdCBjaGlsZHJlblhNTCA9IGNoaWxkcmVuLm1hcChnZXROb2RlWE1MKS5qb2luKFwiXCIpO1xyXG4gICAgaW5jbHVkZWROb2RlSWRzLmFkZChub2RlLmlkKTtcclxuXHJcbiAgICByZXR1cm4gYDxub2RlIElEPVwiJHtub2RlLmlkfVwiIFRFWFQ9XCIke25vZGUudG9waWN9XCIke25vZGUuaXNyb290ID8gJyBST09UPVwidHJ1ZVwiJyA6IFwiXCJcclxuICAgICAgfSBCQUNLR1JPVU5EX0NPTE9SPVwiJHtiYWNrZ3JvdW5kQ29sb3J9XCI+JHtjaGlsZHJlblhNTH08L25vZGU+YDtcclxuICB9O1xyXG5cclxuICBjb25zdCByb290Tm9kZSA9IG1pbmRNYXAuZmluZCgobikgPT4gbi5pc3Jvb3QpIHx8IG1pbmRNYXBbMF07XHJcbiAgbGV0IHhtbFN0cmluZyA9IGA8bWFwIHZlcnNpb249XCIxLjAuMVwiPlxcbjwhLS0gVG8gdmlldyB0aGlzIGZpbGUsIGRvd25sb2FkIGZyZWUgbWluZCBtYXBwaW5nIHNvZnR3YXJlIEZyZWVNaW5kIGZyb20gaHR0cDovL2ZyZWVtaW5kLnNvdXJjZWZvcmdlLm5ldCAtLT5cXG5gO1xyXG5cclxuICBpZiAocm9vdE5vZGUpIHtcclxuICAgIHhtbFN0cmluZyArPSBgJHtnZXROb2RlWE1MKHJvb3ROb2RlKX1cXG5gO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBtaW5kTWFwLmZvckVhY2goKG5vZGUpID0+IHtcclxuICAgICAgaWYgKCFpbmNsdWRlZE5vZGVJZHMuaGFzKG5vZGUuaWQpKSB7XHJcbiAgICAgICAgeG1sU3RyaW5nICs9IGAke2dldE5vZGVYTUwobm9kZSl9XFxuYDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICB4bWxTdHJpbmcgKz0gYDwvbWFwPmA7XHJcbiAgcmV0dXJuIHhtbFN0cmluZztcclxufTtcclxuXHJcbmNvbnN0IGpzb25Ub1hNTFNlbGVjdE5vZGUgPSAobm9kZTogTm9kZSk6IHN0cmluZyA9PiB7XHJcbiAgbGV0IGJhY2tncm91bmRDb2xvciA9IFwiXCI7XHJcblxyXG4gIGlmIChub2RlLnR5cGUgPT09IFwiSWRlYVwiKSB7XHJcbiAgICBiYWNrZ3JvdW5kQ29sb3IgPSBcIiMwMDgwMDBcIjsgLy8gR3JlZW5cclxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJDb250ZXh0XCIpIHtcclxuICAgIGJhY2tncm91bmRDb2xvciA9IFwiIzgwODA4MFwiOyAvLyBHcmV5XHJcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiQ29udGVudFwiKSB7XHJcbiAgICBiYWNrZ3JvdW5kQ29sb3IgPSBcIiNGRkZGRkZcIjsgLy8gV2hpdGVcclxuICB9XHJcblxyXG4gIHJldHVybiBgPG5vZGUgSUQ9XCIke25vZGUuaWR9XCIgVEVYVD1cIiR7bm9kZS50b3BpY31cIiR7bm9kZS5pc3Jvb3QgPyAnIFJPT1Q9XCJ0cnVlXCInIDogXCJcIlxyXG4gICAgfSBCQUNLR1JPVU5EX0NPTE9SPVwiJHtiYWNrZ3JvdW5kQ29sb3J9XCI+PC9ub2RlPmA7XHJcbn07XHJcblxyXG5jb25zdCB4bWxUb0pzb24gPSAoeG1sU3RyaW5nOiBzdHJpbmcpOiBOb2RlW10gPT4ge1xyXG4gIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcclxuICBjb25zdCB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbFN0cmluZywgXCJhcHBsaWNhdGlvbi94bWxcIik7XHJcbiAgY29uc3Qgbm9kZXM6IE5vZGVbXSA9IFtdO1xyXG4gIGxldCBpc0ZpcnN0Tm9kZSA9IHRydWU7XHJcblxyXG4gIGNvbnN0IHBhcnNlTm9kZSA9ICh4bWxOb2RlOiBFbGVtZW50LCBwYXJlbnRJZD86IHN0cmluZykgPT4ge1xyXG4gICAgY29uc3QgaWQgPSBwYXJlbnRJZCA/IHhtbE5vZGUuZ2V0QXR0cmlidXRlKFwiSURcIikhIDogXCJyb290XCI7XHJcbiAgICBjb25zdCB0b3BpYyA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKFwiVEVYVFwiKSE7XHJcbiAgICBsZXQgdHlwZSA9IGRldGVybWluZU5vZGVUeXBlKHhtbE5vZGUuZ2V0QXR0cmlidXRlKFwiQkFDS0dST1VORF9DT0xPUlwiKSk7XHJcblxyXG4gICAgaWYgKHR5cGUgPT09IFwiVW5rbm93blwiKSB7XHJcbiAgICAgIGlmIChpc0ZpcnN0Tm9kZSkge1xyXG4gICAgICAgIHR5cGUgPSBcImRlZmF1bHRcIjtcclxuICAgICAgICBpc0ZpcnN0Tm9kZSA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHR5cGUgPSBcIkNvbnRlbnRcIjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5vZGU6IE5vZGUgPSB7IGlkLCB0b3BpYywgdHlwZSwgcGFyZW50aWQ6IHBhcmVudElkIH07XHJcblxyXG4gICAgaWYgKCFwYXJlbnRJZCkge1xyXG4gICAgICBub2RlLmlzcm9vdCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xyXG5cclxuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB4bWxOb2RlLmNoaWxkcmVuO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHBhcnNlTm9kZShjaGlsZE5vZGVzW2ldIGFzIEVsZW1lbnQsIGlkKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCByb290RWxlbWVudCA9IHhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcIm5vZGVcIilbMF07XHJcblxyXG4gIGlmIChyb290RWxlbWVudCkge1xyXG4gICAgcGFyc2VOb2RlKHJvb3RFbGVtZW50KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBub2RlcztcclxufTtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgbm9kZSB0eXBlIGJhc2VkIG9uIGNvbG9yXHJcbmNvbnN0IGRldGVybWluZU5vZGVUeXBlID0gKGNvbG9yOiBzdHJpbmcgfCBudWxsKTogc3RyaW5nID0+IHtcclxuICBzd2l0Y2ggKGNvbG9yKSB7XHJcbiAgICBjYXNlIFwiIzAwODAwMFwiOlxyXG4gICAgICByZXR1cm4gXCJJZGVhXCI7XHJcbiAgICBjYXNlIFwiIzgwODA4MFwiOlxyXG4gICAgICByZXR1cm4gXCJDb250ZXh0XCI7XHJcbiAgICBjYXNlIFwiI0ZGRkZGRlwiOlxyXG4gICAgICByZXR1cm4gXCJDb250ZW50XCI7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gXCJVbmtub3duXCI7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgdXNlTWluZE1hcFN0b3JlID0gY3JlYXRlPE1pbmRNYXBTdGF0ZT4oKHNldCkgPT4gKHtcclxuICBtaW5kczogW10sXHJcbiAgY3VycmVudE1pbmQ6IG51bGwsXHJcbiAgY29tbWFuZFRvRXhlY3V0ZTogbnVsbCxcclxuICBzZXRDb21tYW5kVG9FeGVjdXRlOiAoY29tbWFuZCkgPT4gc2V0KHsgY29tbWFuZFRvRXhlY3V0ZTogY29tbWFuZCB9KSxcclxuICBzZXRNaW5kczogKG5ld01pbmRzKSA9PiB7XHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIm1pbmRNYXBEYXRhXCIsIEpTT04uc3RyaW5naWZ5KG5ld01pbmRzKSk7XHJcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwcm9qZWN0Q2hhbmdlZFwiKSk7XHJcbiAgICBzZXQoeyBtaW5kczogbmV3TWluZHMgfSk7XHJcbiAgfSxcclxuICBhZGROb2RlOiAocGFyZW50Tm9kZUlkLCBuZXdOb2RlKSA9PlxyXG4gICAgc2V0KChzdGF0ZSkgPT4ge1xyXG4gICAgICBjb25zdCBtaW5kID0gc3RhdGUubWluZHNbMF07XHJcbiAgICAgIGNvbnN0IHBhcmVudE5vZGVFeGlzdHMgPSBtaW5kLmRhdGEuc29tZShcclxuICAgICAgICAobm9kZSkgPT4gbm9kZS5pZCA9PT0gcGFyZW50Tm9kZUlkXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAocGFyZW50Tm9kZUV4aXN0cykge1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRNaW5kID0ge1xyXG4gICAgICAgICAgLi4ubWluZCxcclxuICAgICAgICAgIGRhdGE6IFsuLi5taW5kLmRhdGEsIHsgLi4ubmV3Tm9kZSwgcGFyZW50aWQ6IHBhcmVudE5vZGVJZCB9XSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCB1cGRhdGVkTWluZHMgPSBzdGF0ZS5taW5kcy5tYXAoKG0sIGluZGV4KSA9PlxyXG4gICAgICAgICAgaW5kZXggPT09IDAgPyB1cGRhdGVkTWluZCA6IG1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIm1pbmRNYXBEYXRhXCIsIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRNaW5kcykpO1xyXG4gICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInByb2plY3RDaGFuZ2VkXCIpKTtcclxuICAgICAgICByZXR1cm4geyBtaW5kczogdXBkYXRlZE1pbmRzIH07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbWVzc2FnZS5lcnJvcihcIlBhcmVudCBub2RlIG5vdCBmb3VuZFwiKTtcclxuICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgIH1cclxuICAgIH0pLFxyXG4gIGRlbGV0ZU5vZGU6IChub2RlSWQpID0+XHJcbiAgICBzZXQoKHN0YXRlKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRlbGV0ZU5vZGVBbmRDaGlsZHJlbiA9IChub2RlczogTm9kZVtdLCBpZDogc3RyaW5nKTogTm9kZVtdID0+IHtcclxuICAgICAgICBjb25zdCBjaGlsZHJlbklkcyA9IG5vZGVzXHJcbiAgICAgICAgICAuZmlsdGVyKChub2RlKSA9PiBub2RlLnBhcmVudGlkID09PSBpZClcclxuICAgICAgICAgIC5tYXAoKG5vZGUpID0+IG5vZGUuaWQpO1xyXG4gICAgICAgIGxldCBmaWx0ZXJlZE5vZGVzID0gbm9kZXMuZmlsdGVyKChub2RlKSA9PiBub2RlLmlkICE9PSBpZCk7XHJcbiAgICAgICAgY2hpbGRyZW5JZHMuZm9yRWFjaCgoY2hpbGRJZCkgPT4ge1xyXG4gICAgICAgICAgZmlsdGVyZWROb2RlcyA9IGRlbGV0ZU5vZGVBbmRDaGlsZHJlbihmaWx0ZXJlZE5vZGVzLCBjaGlsZElkKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZmlsdGVyZWROb2RlcztcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnN0IHVwZGF0ZWRNaW5kcyA9IHN0YXRlLm1pbmRzLm1hcCgobWluZCkgPT4gKHtcclxuICAgICAgICAuLi5taW5kLFxyXG4gICAgICAgIGRhdGE6IGRlbGV0ZU5vZGVBbmRDaGlsZHJlbihtaW5kLmRhdGEsIG5vZGVJZCksXHJcbiAgICAgIH0pKTtcclxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJtaW5kTWFwRGF0YVwiLCBKU09OLnN0cmluZ2lmeSh1cGRhdGVkTWluZHMpKTtcclxuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicHJvamVjdENoYW5nZWRcIikpO1xyXG4gICAgICByZXR1cm4geyBtaW5kczogdXBkYXRlZE1pbmRzIH07XHJcbiAgICB9KSxcclxuICBpbml0aWFsaXplTWluZE1hcDogKCkgPT4ge1xyXG4gICAgY29uc3QgbWluZERhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm1pbmRNYXBEYXRhXCIpO1xyXG5cclxuICAgIGlmICghbWluZERhdGEgfHwgbWluZERhdGEubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibWluZE1hcERhdGFcIiwgSlNPTi5zdHJpbmdpZnkoW2RlZmF1bHRNaW5kTWFwXSkpO1xyXG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwcm9qZWN0Q2hhbmdlZFwiKSk7XHJcbiAgICAgIHNldCh7IG1pbmRzOiBbZGVmYXVsdE1pbmRNYXBdLCBjdXJyZW50TWluZDogZGVmYXVsdE1pbmRNYXAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBwYXJzZWRNaW5kcyA9IEpTT04ucGFyc2UobWluZERhdGEhKTtcclxuICAgICAgc2V0KHsgbWluZHM6IHBhcnNlZE1pbmRzLCBjdXJyZW50TWluZDogcGFyc2VkTWluZHNbMF0gfSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBjcmVhdGVOZXdQcm9qZWN0OiAocHJvamVjdE5hbWU6IHN0cmluZykgPT5cclxuICAgIHNldCgoc3RhdGUpID0+IHtcclxuICAgICAgaWYgKCFwcm9qZWN0TmFtZSkge1xyXG4gICAgICAgIG1lc3NhZ2UuZXJyb3IoXCJQbGVhc2UgaW5wdXQgcHJvamVjdCBuYW1lXCIpO1xyXG4gICAgICAgIHJldHVybiB7IG1pbmRzOiBzdGF0ZS5taW5kcyB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXRyaWV2ZSBleGlzdGluZyBwcm9qZWN0cyBmcm9tIGxvY2FsU3RvcmFnZVxyXG4gICAgICBjb25zdCBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJtaW5kTWFwRGF0YVwiKTtcclxuICAgICAgbGV0IG5ld1Byb2plY3ROYW1lID0gcHJvamVjdE5hbWU7XHJcblxyXG4gICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBwYXJzZWRNaW5kcyA9IEpTT04ucGFyc2UoZGF0YSkgYXMgbWluZE1hcFtdO1xyXG5cclxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBleGFjdCBwcm9qZWN0IG5hbWUgZXhpc3RzXHJcbiAgICAgICAgICBjb25zdCBleGFjdFByb2plY3RFeGlzdHMgPSBwYXJzZWRNaW5kcy5zb21lKFxyXG4gICAgICAgICAgICAocHJvamVjdCkgPT4gcHJvamVjdC5wcm9qZWN0TmFtZSA9PT0gcHJvamVjdE5hbWVcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgaWYgKGV4YWN0UHJvamVjdEV4aXN0cykge1xyXG4gICAgICAgICAgICAvLyBGaWx0ZXIgdGhlIGV4aXN0aW5nIHByb2plY3RzIHRoYXQgc3RhcnQgd2l0aCB0aGUgc2FtZSBiYXNlIG5hbWVcclxuICAgICAgICAgICAgbGV0IGV4aXN0aW5nUHJvamVjdHMgPSBwYXJzZWRNaW5kcy5maWx0ZXIoXHJcbiAgICAgICAgICAgICAgKGl0ZW0pID0+IGl0ZW0ucHJvamVjdE5hbWUuc3RhcnRzV2l0aChwcm9qZWN0TmFtZSlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbGxlY3Qgc3VmZml4ZXMgZm9yIGFsbCBtYXRjaGluZyBwcm9qZWN0cyAoZS5nLiwgcHJvamVjdDEsIHByb2plY3QyLCBldGMuKVxyXG4gICAgICAgICAgICBjb25zdCBzdWZmaXhlcyA9IGV4aXN0aW5nUHJvamVjdHMubWFwKChwcm9qZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBwcm9qZWN0LnByb2plY3ROYW1lLm1hdGNoKG5ldyBSZWdFeHAoYF4ke3Byb2plY3ROYW1lfSAoXFxcXGQrKSRgKSk7XHJcbiAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH0pLmZpbHRlcihzdWZmaXggPT4gc3VmZml4ICE9PSBudWxsKSBhcyBudW1iZXJbXTsgLy8gUmVtb3ZlIG5vbi1udW1lcmljIG1hdGNoZXNcclxuXHJcbiAgICAgICAgICAgIC8vIFNvcnQgc3VmZml4ZXMgdG8gaWRlbnRpZnkgZ2Fwc1xyXG4gICAgICAgICAgICBzdWZmaXhlcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcblxyXG4gICAgICAgICAgICBsZXQgbmV3U3VmZml4ID0gMTsgLy8gU3RhcnQgZnJvbSAxLCBhcyB3ZSBhcmUgbG9va2luZyBmb3IgJ3Byb2plY3QgMScsICdwcm9qZWN0IDInLCBldGMuXHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1ZmZpeGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHN1ZmZpeGVzW2ldID09PSBuZXdTdWZmaXgpIHtcclxuICAgICAgICAgICAgICAgIG5ld1N1ZmZpeCsrO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gRm91bmQgYSBnYXAsIHN0b3AgaGVyZVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBuZXcgcHJvamVjdCBuYW1lIHRvICdwcm9qZWN0ICcgKyBuZXdTdWZmaXggKGUuZy4sICdwcm9qZWN0IDEnLCAncHJvamVjdCAyJylcclxuICAgICAgICAgICAgbmV3UHJvamVjdE5hbWUgPSBwcm9qZWN0TmFtZSArIFwiIFwiICsgbmV3U3VmZml4O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIG1pbmQgbWFwIGRhdGE6XCIsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgbmV3IHByb2plY3Qgd2l0aCB0aGUgdXBkYXRlZCBwcm9qZWN0IG5hbWVcclxuICAgICAgY29uc3QgbmV3TWluZE1hcCA9IHtcclxuICAgICAgICAuLi5kZWZhdWx0TWluZE1hcCxcclxuICAgICAgICBwcm9qZWN0TmFtZTogbmV3UHJvamVjdE5hbWUsXHJcbiAgICAgICAgZGF0YTogW3sgaWQ6IFwicm9vdFwiLCBpc3Jvb3Q6IHRydWUsIHRvcGljOiBcIk5ldyBNaW5kTWFwXCIsIHR5cGU6IFwicm9vdFwiIH1dLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHRoZSBzdGF0ZSBhbmQgbG9jYWxTdG9yYWdlXHJcbiAgICAgIGNvbnN0IHVwZGF0ZWRNaW5kcyA9IFtuZXdNaW5kTWFwLCAuLi5zdGF0ZS5taW5kc107XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibWluZE1hcERhdGFcIiwgSlNPTi5zdHJpbmdpZnkodXBkYXRlZE1pbmRzKSk7XHJcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInByb2plY3RDaGFuZ2VkXCIpKTtcclxuXHJcbiAgICAgIHJldHVybiB7IG1pbmRzOiB1cGRhdGVkTWluZHMsIGN1cnJlbnRNaW5kOiBuZXdNaW5kTWFwIH07XHJcbiAgICB9KSxcclxuXHJcblxyXG4gIGdldFByb2plY3RzOiAoKSA9PiB7XHJcbiAgICBjb25zdCBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJtaW5kTWFwRGF0YVwiKTtcclxuICAgIGlmIChkYXRhKSB7XHJcbiAgICAgIGNvbnN0IHBhcnNlZE1pbmRzID0gSlNPTi5wYXJzZShkYXRhKSBhcyBtaW5kTWFwW107XHJcbiAgICAgIHJldHVybiBwYXJzZWRNaW5kcy5tYXAoKG1pbmQpID0+IG1pbmQucHJvamVjdE5hbWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH0sXHJcbiAgc2V0Q3VycmVudFByb2plY3Q6IChwcm9qZWN0TmFtZTogc3RyaW5nKSA9PlxyXG4gICAgc2V0KChzdGF0ZSkgPT4ge1xyXG4gICAgICBjb25zdCBzZWxlY3RlZE1pbmQgPSBzdGF0ZS5taW5kcy5maW5kKFxyXG4gICAgICAgIChtaW5kKSA9PiBtaW5kLnByb2plY3ROYW1lID09PSBwcm9qZWN0TmFtZVxyXG4gICAgICApO1xyXG4gICAgICBpZiAoc2VsZWN0ZWRNaW5kKSB7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZE1pbmRzID0gW1xyXG4gICAgICAgICAgc2VsZWN0ZWRNaW5kLFxyXG4gICAgICAgICAgLi4uc3RhdGUubWluZHMuZmlsdGVyKChtaW5kKSA9PiBtaW5kLnByb2plY3ROYW1lICE9PSBwcm9qZWN0TmFtZSksXHJcbiAgICAgICAgXTtcclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIm1pbmRNYXBEYXRhXCIsIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRNaW5kcykpO1xyXG4gICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInByb2plY3RDaGFuZ2VkXCIpKTtcclxuICAgICAgICByZXR1cm4geyBtaW5kczogdXBkYXRlZE1pbmRzLCBjdXJyZW50TWluZDogc2VsZWN0ZWRNaW5kIH07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgfSksXHJcbiAgc2V0TWluZE1hcFByb2plY3ROYW1lOiAocHJvamVjdE5hbWU6IHN0cmluZykgPT4ge1xyXG4gICAgY29uc3QgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibWluZE1hcERhdGFcIik7XHJcbiAgICBpZiAoZGF0YSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZE1pbmRzID0gSlNPTi5wYXJzZShkYXRhKSBhcyBtaW5kTWFwW107XHJcblxyXG4gICAgICAgIGxldCBuZXdQcm9qZWN0TmFtZSA9IHByb2plY3ROYW1lO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgZXhhY3QgcHJvamVjdCBuYW1lIGV4aXN0c1xyXG4gICAgICAgIGNvbnN0IGV4YWN0UHJvamVjdEV4aXN0cyA9IHBhcnNlZE1pbmRzLnNvbWUoXHJcbiAgICAgICAgICAocHJvamVjdCkgPT4gcHJvamVjdC5wcm9qZWN0TmFtZSA9PT0gcHJvamVjdE5hbWVcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAoZXhhY3RQcm9qZWN0RXhpc3RzKSB7XHJcbiAgICAgICAgICAvLyBGaWx0ZXIgdGhlIGV4aXN0aW5nIHByb2plY3RzIHRoYXQgc3RhcnQgd2l0aCB0aGUgc2FtZSBiYXNlIG5hbWVcclxuICAgICAgICAgIGxldCBleGlzdGluZ1Byb2plY3RzID0gcGFyc2VkTWluZHMuZmlsdGVyKFxyXG4gICAgICAgICAgICAoaXRlbSkgPT4gaXRlbS5wcm9qZWN0TmFtZS5zdGFydHNXaXRoKHByb2plY3ROYW1lKVxyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAvLyBDb2xsZWN0IHN1ZmZpeGVzIGZvciBhbGwgbWF0Y2hpbmcgcHJvamVjdHMgKGUuZy4sIHByb2plY3QxLCBwcm9qZWN0MiwgZXRjLilcclxuICAgICAgICAgIGNvbnN0IHN1ZmZpeGVzID0gZXhpc3RpbmdQcm9qZWN0cy5tYXAoKHByb2plY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBwcm9qZWN0LnByb2plY3ROYW1lLm1hdGNoKG5ldyBSZWdFeHAoYF4ke3Byb2plY3ROYW1lfSAoXFxcXGQrKSRgKSk7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChtYXRjaFsxXSwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgfSkuZmlsdGVyKHN1ZmZpeCA9PiBzdWZmaXggIT09IG51bGwpIGFzIG51bWJlcltdOyAvLyBSZW1vdmUgbm9uLW51bWVyaWMgbWF0Y2hlc1xyXG5cclxuICAgICAgICAgIC8vIFNvcnQgc3VmZml4ZXMgdG8gaWRlbnRpZnkgZ2Fwc1xyXG4gICAgICAgICAgc3VmZml4ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG5cclxuICAgICAgICAgIGxldCBuZXdTdWZmaXggPSAxOyAvLyBTdGFydCBmcm9tIDEsIGFzIHdlIGFyZSBsb29raW5nIGZvciAncHJvamVjdCAxJywgJ3Byb2plY3QgMicsIGV0Yy5cclxuXHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1ZmZpeGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChzdWZmaXhlc1tpXSA9PT0gbmV3U3VmZml4KSB7XHJcbiAgICAgICAgICAgICAgbmV3U3VmZml4Kys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgYnJlYWs7IC8vIEZvdW5kIGEgZ2FwLCBzdG9wIGhlcmVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFNldCB0aGUgbmV3IHByb2plY3QgbmFtZSB0byAncHJvamVjdCAnICsgbmV3U3VmZml4IChlLmcuLCAncHJvamVjdCAxJywgJ3Byb2plY3QgMicpXHJcbiAgICAgICAgICBuZXdQcm9qZWN0TmFtZSA9IHByb2plY3ROYW1lICsgXCIgXCIgKyBuZXdTdWZmaXg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIHByb2plY3QgbmFtZSBmb3IgdGhlIGZpcnN0IGl0ZW1cclxuICAgICAgICBpZiAocGFyc2VkTWluZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgcGFyc2VkTWluZHNbMF0ucHJvamVjdE5hbWUgPSBuZXdQcm9qZWN0TmFtZTtcclxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibWluZE1hcERhdGFcIiwgSlNPTi5zdHJpbmdpZnkocGFyc2VkTWluZHMpKTtcclxuICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInByb2plY3RDaGFuZ2VkXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBtaW5kIG1hcCBkYXRhOlwiLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuXHJcbiAgZGVsZXRlTWluZE1hcFByb2plY3Q6ICgpID0+IHtcclxuICAgIGNvbnN0IGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm1pbmRNYXBEYXRhXCIpO1xyXG5cclxuICAgIGlmIChkYXRhKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkTWluZHMgPSBKU09OLnBhcnNlKGRhdGEpIGFzIG1pbmRNYXBbXTtcclxuICAgICAgICBpZiAocGFyc2VkTWluZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgcGFyc2VkTWluZHMuc2hpZnQoKTtcclxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibWluZE1hcERhdGFcIiwgSlNPTi5zdHJpbmdpZnkocGFyc2VkTWluZHMpKTtcclxuICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInByb2plY3RDaGFuZ2VkXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBtaW5kIG1hcCBkYXRhOlwiLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIGRvd25sb2FkRnJlZW1pbmQ6ICgpID0+IHtcclxuICAgIGNvbnN0IGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm1pbmRNYXBEYXRhXCIpO1xyXG4gICAgaWYgKGRhdGEpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBwYXJzZWRNaW5kcyA9IEpTT04ucGFyc2UoZGF0YSkgYXMgbWluZE1hcFtdO1xyXG4gICAgICAgIGNvbnN0IG1pbmRNYXBUb0Rvd25sb2FkID0gcGFyc2VkTWluZHNbMF0uZGF0YTsgLy8gQXNzdW1pbmcgeW91IHdhbnQgdG8gZG93bmxvYWQgdGhlIGZpcnN0IG1pbmQgbWFwXHJcblxyXG4gICAgICAgIGNvbnN0IHhtbERhdGEgPSBqc29uVG9YTUwobWluZE1hcFRvRG93bmxvYWQpO1xyXG5cclxuICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW3htbERhdGFdLCB7IHR5cGU6IFwiYXBwbGljYXRpb24veG1sXCIgfSk7XHJcbiAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgICAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgICAgICAgYS5ocmVmID0gdXJsO1xyXG4gICAgICAgIGEuZG93bmxvYWQgPSBgJHtwYXJzZWRNaW5kc1swXS5wcm9qZWN0TmFtZX0ubW1gO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7XHJcbiAgICAgICAgYS5jbGljaygpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBtaW5kIG1hcCBkYXRhOlwiLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIGRvd25sb2FkUHJvamVjdDogKCkgPT4ge1xyXG4gICAgY29uc3QgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibWluZE1hcERhdGFcIik7XHJcbiAgICBpZiAoZGF0YSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZE1pbmRzID0gSlNPTi5wYXJzZShkYXRhKSBhcyBtaW5kTWFwW107XHJcbiAgICAgICAgY29uc3QgbWluZE1hcFRvRG93bmxvYWQgPSBwYXJzZWRNaW5kc1swXTsgLy8gQXNzdW1pbmcgeW91IHdhbnQgdG8gZG93bmxvYWQgdGhlIGZpcnN0IG1pbmQgbWFwXHJcblxyXG4gICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkobWluZE1hcFRvRG93bmxvYWQpXSwge1xyXG4gICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgICAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgICAgICAgYS5ocmVmID0gdXJsO1xyXG4gICAgICAgIGEuZG93bmxvYWQgPSBgJHttaW5kTWFwVG9Eb3dubG9hZC5wcm9qZWN0TmFtZX0uanNvbmA7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTtcclxuICAgICAgICBhLmNsaWNrKCk7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIG1pbmQgbWFwIGRhdGE6XCIsIGVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgbG9hZFByb2plY3Q6IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBsb2FkRnJvbUpTT04oKTsgLy8gQXNzdW1pbmcgbG9hZEZyb21KU09OIHJldHVybnMgdGhlIGxvYWRlZCBkYXRhIGFzIE1pbmRNYXBcclxuXHJcbiAgICAgIHJlc3RvcmVEYXRhKGRhdGEpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBsb2FkIEZyZWVtaW5kIGRhdGE6XCIsIGVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuICBsb2FkRnJlZU1pbmQ6IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGZpbGUgPSBhd2FpdCBsb2FkRnJvbU1NKCk7XHJcbiAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG5cclxuICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeG1sU3RyaW5nID0gZmlsZVJlYWRlci5yZXN1bHQgYXMgc3RyaW5nO1xyXG4gICAgICAgIGNvbnN0IGpzb25EYXRhID0geG1sVG9Kc29uKHhtbFN0cmluZyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0b3JhZ2VEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJtaW5kTWFwRGF0YVwiKTtcclxuICAgICAgICBpZiAoc3RvcmFnZURhdGEpIHtcclxuICAgICAgICAgIGNvbnN0IG1pbmREYXRhID0gSlNPTi5wYXJzZShzdG9yYWdlRGF0YSkgYXMgbWluZE1hcFtdO1xyXG5cclxuICAgICAgICAgIGNvbnN0IG5ld01pbmRNYXA6IG1pbmRNYXAgPSB7XHJcbiAgICAgICAgICAgIG1ldGE6IHtcclxuICAgICAgICAgICAgICBuYW1lOiBcIk1pbmRNYXBcIixcclxuICAgICAgICAgICAgICB2ZXJzaW9uOiBcIjAuMlwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmb3JtYXQ6IFwibm9kZV9hcnJheVwiLFxyXG4gICAgICAgICAgICBwcm9qZWN0TmFtZTogYE5ldyBGcmVlbWluZCAke25ldyBEYXRlKCkuZ2V0VGltZSgpfWAsXHJcbiAgICAgICAgICAgIGRhdGE6IGpzb25EYXRhLFxyXG4gICAgICAgICAgICBSZXF1ZXN0SW5zdHJ1Y3Rpb246IFwiXCIsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb246IHtcclxuICAgICAgICAgICAgICBvcGVuQUlLZXk6IFwiXCIsXHJcbiAgICAgICAgICAgICAgZGVmYXVsdEFzc2lzdGFudElkOiBcIlwiLFxyXG4gICAgICAgICAgICAgIGRlZmF1bHRUaHJlYWRJZDogXCJcIixcclxuICAgICAgICAgICAgICBjb21tYW5kczogW10sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIG1pbmREYXRhLnVuc2hpZnQobmV3TWluZE1hcCk7XHJcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIm1pbmRNYXBEYXRhXCIsIEpTT04uc3RyaW5naWZ5KG1pbmREYXRhKSk7XHJcbiAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwcm9qZWN0Q2hhbmdlZFwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgZmlsZVJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcbiAgc2V0UmVxdWVzdENvbnRlbnQ6ICh2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICBjb25zdCBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJtaW5kTWFwRGF0YVwiKTtcclxuICAgIGlmIChkYXRhKSB7XHJcbiAgICAgIGNvbnN0IG1pbmREYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcclxuXHJcbiAgICAgIG1pbmREYXRhWzBdLlJlcXVlc3RJbnN0cnVjdGlvbiA9IHZhbHVlO1xyXG5cclxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJtaW5kTWFwRGF0YVwiLCBKU09OLnN0cmluZ2lmeShtaW5kRGF0YSkpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgZ2V0RGF0YXM6ICgpID0+IHtcclxuICAgIGNvbnN0IGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm1pbmRNYXBEYXRhXCIpO1xyXG4gICAgaWYgKGRhdGEpIHtcclxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfSxcclxuICBzYXZlQ29uZmlndXJhdGlvbkRlZmF1bHRWYWx1ZTogKFxyXG4gICAgb3BlbkFJS2V5OiBzdHJpbmcsXHJcbiAgICBkZWZhdWx0QXNzaXN0YW50SWQ6IHN0cmluZyxcclxuICAgIGRlZmF1bHRUaHJlYWRJZDogc3RyaW5nXHJcbiAgKSA9PiB7XHJcbiAgICBjb25zdCBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJtaW5kTWFwRGF0YVwiKTtcclxuICAgIGlmIChkYXRhKSB7XHJcbiAgICAgIGNvbnN0IG1pbmREYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcclxuXHJcbiAgICAgIG1pbmREYXRhWzBdLmNvbmZpZ3VyYXRpb24ub3BlbkFJS2V5ID0gb3BlbkFJS2V5O1xyXG4gICAgICBtaW5kRGF0YVswXS5jb25maWd1cmF0aW9uLmRlZmF1bHRBc3Npc3RhbnRJZCA9IGRlZmF1bHRBc3Npc3RhbnRJZDtcclxuICAgICAgbWluZERhdGFbMF0uY29uZmlndXJhdGlvbi5kZWZhdWx0VGhyZWFkSWQgPSBkZWZhdWx0VGhyZWFkSWQ7XHJcblxyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIm1pbmRNYXBEYXRhXCIsIEpTT04uc3RyaW5naWZ5KG1pbmREYXRhKSk7XHJcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInByb2plY3RDaGFuZ2VkXCIpKTtcclxuICAgIH1cclxuICB9LFxyXG4gIGFkZENvbW1hbmQ6ICgpID0+IHtcclxuICAgIGxldCBpZGVhID0gWzAsIDBdXHJcbiAgICBsZXQgY29udGVudCA9IFswLCAwXVxyXG4gICAgbGV0IGNvbnRleHQgPSBbMCwgMF1cclxuXHJcbiAgICBjb25zdCBjb21tYW5kOiBDb21tYW5kcyA9IHtcclxuICAgICAgY29tbWFuZE5hbWU6IFwiXCIsXHJcbiAgICAgIGFzc2lzdGFudElkOiBcIlwiLFxyXG4gICAgICB0aHJlYWRJZDogXCJcIixcclxuICAgICAgc2VsZWN0OiBcIlwiLFxyXG4gICAgICBpZGVhOiBpZGVhLFxyXG4gICAgICBjb250ZW50OiBjb250ZW50LFxyXG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxyXG4gICAgICBjb21tYW5kczogXCJcIixcclxuICAgICAgY29tbWFuZEtleTogbmV3IERhdGUoKS50b1N0cmluZygpLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBzdG9yYWdlRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibWluZE1hcERhdGFcIik7XHJcblxyXG4gICAgaWYgKHN0b3JhZ2VEYXRhKSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHN0b3JhZ2VEYXRhKTtcclxuICAgICAgZGF0YVswXS5jb25maWd1cmF0aW9uLmNvbW1hbmRzLnB1c2goY29tbWFuZCk7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibWluZE1hcERhdGFcIiwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xyXG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwcm9qZWN0Q2hhbmdlZFwiKSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBkZWxldGVDb21tYW5kOiAoaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgY29uc3Qgc3RvcmFnZURhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm1pbmRNYXBEYXRhXCIpO1xyXG4gICAgaWYgKHN0b3JhZ2VEYXRhKSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHN0b3JhZ2VEYXRhKTtcclxuICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGRhdGFbMF0uY29uZmlndXJhdGlvbi5jb21tYW5kcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibWluZE1hcERhdGFcIiwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xyXG4gICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInByb2plY3RDaGFuZ2VkXCIpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgc2F2ZUNvbW1hbmQ6IChcclxuICAgIGNvbW1hbmROYW1lOiBzdHJpbmcsXHJcbiAgICBhc3Npc3RhbnRJZDogc3RyaW5nLFxyXG4gICAgdGhyZWFkSWQ6IHN0cmluZyxcclxuICAgIHNlbGVjdDogc3RyaW5nLFxyXG4gICAgaWRlYTogbnVtYmVyW10sXHJcbiAgICBjb250ZXh0OiBudW1iZXJbXSxcclxuICAgIGNvbnRlbnQ6IG51bWJlcltdLFxyXG4gICAgY29tbWFuZHM6IHN0cmluZyxcclxuICAgIGlkOiBudW1iZXJcclxuICApID0+IHtcclxuICAgIGNvbnN0IHN0b3JhZ2VEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJtaW5kTWFwRGF0YVwiKTtcclxuICAgIGlmIChzdG9yYWdlRGF0YSkge1xyXG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShzdG9yYWdlRGF0YSk7XHJcblxyXG4gICAgICBjb25zdCBjb21tYW5kOiBDb21tYW5kcyA9IHtcclxuICAgICAgICBjb21tYW5kTmFtZSxcclxuICAgICAgICBhc3Npc3RhbnRJZCxcclxuICAgICAgICB0aHJlYWRJZCxcclxuICAgICAgICBzZWxlY3QsXHJcbiAgICAgICAgaWRlYTogaWRlYSxcclxuICAgICAgICBjb250ZW50OiBjb250ZW50LFxyXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXHJcbiAgICAgICAgY29tbWFuZHMsXHJcbiAgICAgICAgY29tbWFuZEtleTogbmV3IERhdGUoKS50b1N0cmluZygpLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgZGF0YVswXS5jb25maWd1cmF0aW9uLmNvbW1hbmRzW2lkXSA9IGNvbW1hbmQ7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibWluZE1hcERhdGFcIiwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xyXG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwcm9qZWN0Q2hhbmdlZFwiKSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBnZXRDb21tYW5kOiAoaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgY29uc3QgbWluZE1hcERhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm1pbmRNYXBEYXRhXCIpO1xyXG5cclxuICAgIGlmIChtaW5kTWFwRGF0YSkge1xyXG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShtaW5kTWFwRGF0YSk7XHJcblxyXG4gICAgICBpZiAoZGF0YVswXS5jb25maWd1cmF0aW9uLmNvbW1hbmRzWzBdKSB7XHJcbiAgICAgICAgbGV0IGNvbW1hbmREYXRhOiBDb21tYW5kcztcclxuXHJcbiAgICAgICAgY29tbWFuZERhdGEgPSBkYXRhWzBdLmNvbmZpZ3VyYXRpb24uY29tbWFuZHNbaW5kZXhdO1xyXG5cclxuICAgICAgICBjb25zdCBjb21tYW5kOiBSZXR1cm5Db21tYW5kID0ge1xyXG4gICAgICAgICAgY29tbWFuZE5hbWU6IGNvbW1hbmREYXRhLmNvbW1hbmROYW1lLFxyXG4gICAgICAgICAgYXNzaXN0YW50SWQ6IGNvbW1hbmREYXRhLmFzc2lzdGFudElkLFxyXG4gICAgICAgICAgdGhyZWFkSWQ6IGNvbW1hbmREYXRhLnRocmVhZElkLFxyXG4gICAgICAgICAgc2VsZWN0OiBjb21tYW5kRGF0YS5zZWxlY3QsXHJcbiAgICAgICAgICBjb21tYW5kczogY29tbWFuZERhdGEuY29tbWFuZHMsXHJcbiAgICAgICAgICBpZGVhOiBjb21tYW5kRGF0YS5pZGVhLFxyXG4gICAgICAgICAgY29udGV4dDogY29tbWFuZERhdGEuY29udGV4dCxcclxuICAgICAgICAgIGNvbnRlbnQ6IGNvbW1hbmREYXRhLmNvbnRlbnQsXHJcbiAgICAgICAgICBjb21tYW5kS2V5OiBuZXcgRGF0ZSgpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbW1hbmQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRSZXR1cm5Db21tYW5kO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVmYXVsdFJldHVybkNvbW1hbmQ7XHJcbiAgfSxcclxuICBnZXRDb21tYW5kczogKCkgPT4ge1xyXG4gICAgY29uc3QgbWluZE1hcERhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm1pbmRNYXBEYXRhXCIpO1xyXG5cclxuICAgIGlmIChtaW5kTWFwRGF0YSkge1xyXG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShtaW5kTWFwRGF0YSk7XHJcblxyXG4gICAgICByZXR1cm4gZGF0YVswXS5jb25maWd1cmF0aW9uLmNvbW1hbmRzO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgc2F2ZUNvbW1hbmRSZW9yZGVyOiAoY29tbWFuZHM6IENvbW1hbmRzW10pID0+IHtcclxuICAgIGNvbnN0IG1pbmREYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJtaW5kTWFwRGF0YVwiKTtcclxuXHJcbiAgICBpZiAobWluZERhdGEpIHtcclxuICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UobWluZERhdGEpO1xyXG4gICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgIGRhdGFbMF0uY29uZmlndXJhdGlvbi5jb21tYW5kcyA9IGNvbW1hbmRzO1xyXG5cclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIm1pbmRNYXBEYXRhXCIsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcclxuXHJcbiAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicHJvamVjdENoYW5nZWRcIikpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICB1cGRhdGVOb2RlQ29udGVudDogKG5vZGVJZDogc3RyaW5nLCBuZXdDb250ZW50OiBzdHJpbmcpID0+IHtcclxuICAgIGNvbnN0IG1pbmRNYXBEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJtaW5kTWFwRGF0YVwiKTtcclxuXHJcbiAgICBpZiAobWluZE1hcERhdGEpIHtcclxuICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UobWluZE1hcERhdGEpO1xyXG5cclxuICAgICAgZGF0YVswXS5kYXRhLm1hcCgoaXRlbTogTm9kZSkgPT4ge1xyXG4gICAgICAgIGlmIChpdGVtLmlkID09PSBub2RlSWQpIHtcclxuICAgICAgICAgIGl0ZW0udG9waWMgPSBuZXdDb250ZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIm1pbmRNYXBEYXRhXCIsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcclxuXHJcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInByb2plY3RDaGFuZ2VkXCIpKTtcclxuICAgIH1cclxuICB9LFxyXG4gIGdldERlZmF1bHRUaHJlYWRJZDogKCkgPT4ge1xyXG4gICAgY29uc3QgbWluZE1hcERhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm1pbmRNYXBEYXRhXCIpO1xyXG5cclxuICAgIGlmIChtaW5kTWFwRGF0YSkge1xyXG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShtaW5kTWFwRGF0YSk7XHJcblxyXG4gICAgICByZXR1cm4gZGF0YVswXS5jb25maWd1cmF0aW9uLmRlZmF1bHRUaHJlYWRJZDtcclxuICAgIH1cclxuICB9LFxyXG4gIGdldE9wZW5BSUtleTogKCkgPT4ge1xyXG4gICAgY29uc3QgbWluZE1hcERhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm1pbmRNYXBEYXRhXCIpO1xyXG5cclxuICAgIGlmIChtaW5kTWFwRGF0YSkge1xyXG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShtaW5kTWFwRGF0YSk7XHJcblxyXG4gICAgICByZXR1cm4gZGF0YVswXS5jb25maWd1cmF0aW9uLm9wZW5BSUtleTtcclxuICAgIH1cclxuICB9LFxyXG4gIGdldERlZmF1bHRBc3Npc3RhbnRJZDogKCkgPT4ge1xyXG4gICAgY29uc3QgbWluZE1hcERhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm1pbmRNYXBEYXRhXCIpO1xyXG5cclxuICAgIGlmIChtaW5kTWFwRGF0YSkge1xyXG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShtaW5kTWFwRGF0YSk7XHJcblxyXG4gICAgICByZXR1cm4gZGF0YVswXS5jb25maWd1cmF0aW9uLmRlZmF1bHRBc3Npc3RhbnRJZDtcclxuICAgIH1cclxuICB9LFxyXG4gIGdldENvbmZpZ3VyYXRpb246ICgpID0+IHtcclxuICAgIGNvbnN0IG1pbmRNYXBEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJtaW5kTWFwRGF0YVwiKTtcclxuXHJcbiAgICBpZiAobWluZE1hcERhdGEpIHtcclxuICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UobWluZE1hcERhdGEpO1xyXG5cclxuICAgICAgcmV0dXJuIGRhdGFbMF0uY29uZmlndXJhdGlvbjtcclxuICAgIH1cclxuICB9LFxyXG4gIGV4ZWN1dGVDb21tYW5kOiBhc3luYyAoXHJcbiAgICBrZXk6IG51bWJlcixcclxuICAgIHBhcmVudElkOiBzdHJpbmcsXHJcbiAgICBub2RlOiBhbnksXHJcbiAgICBub2RlVHlwZTogc3RyaW5nLFxyXG4gICAgY2FuY2VsVG9rZW46IGFueVxyXG4gICkgPT4ge1xyXG4gICAgY29uc3QgbWluZE1hcERhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm1pbmRNYXBEYXRhXCIpO1xyXG5cclxuICAgIGlmIChtaW5kTWFwRGF0YSkge1xyXG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShtaW5kTWFwRGF0YSk7XHJcblxyXG4gICAgICBjb25zdCBvcGVuQUlLZXkgPSBkYXRhWzBdLmNvbmZpZ3VyYXRpb24ub3BlbkFJS2V5O1xyXG4gICAgICBjb25zdCBkZWZhdWx0QXNzaXN0YW50SWQgPSBkYXRhWzBdLmNvbmZpZ3VyYXRpb24uZGVmYXVsdEFzc2lzdGFudElkO1xyXG4gICAgICBjb25zdCBkZWZhdWx0VGhyZWFkSWQgPSBkYXRhWzBdLmNvbmZpZ3VyYXRpb24uZGVmYXVsdFRocmVhZElkO1xyXG4gICAgICBjb25zdCByZXF1ZXN0SW5zdHJ1Y3Rpb24gPSBkYXRhWzBdLlJlcXVlc3RJbnN0cnVjdGlvblxyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjdXJyZW50Q29tbWFuZDogQ29tbWFuZHMgPSBkYXRhWzBdLmNvbmZpZ3VyYXRpb24uY29tbWFuZHNba2V5XTtcclxuXHJcbiAgICAgICAgbGV0IGlkZWFIZWFkTGV2ZWwsIGlkZWFEZXB0aCwgY29udGV4dEhlYWRMZXZlbCwgY29udGV4dERlcHRoLCBjb250ZW50SGVhZExldmVsLCBjb250ZW50RGVwdGhcclxuXHJcbiAgICAgICAgaWRlYUhlYWRMZXZlbCA9IGN1cnJlbnRDb21tYW5kLmlkZWFbMF1cclxuICAgICAgICBpZGVhRGVwdGggPSBjdXJyZW50Q29tbWFuZC5pZGVhWzFdIC0gMVxyXG4gICAgICAgIGNvbnRleHRIZWFkTGV2ZWwgPSBjdXJyZW50Q29tbWFuZC5jb250ZXh0WzBdXHJcbiAgICAgICAgY29udGV4dERlcHRoID0gY3VycmVudENvbW1hbmQuY29udGV4dFsxXSAtIDFcclxuICAgICAgICBjb250ZW50SGVhZExldmVsID0gY3VycmVudENvbW1hbmQuY29udGVudFswXVxyXG4gICAgICAgIGNvbnRlbnREZXB0aCA9IGN1cnJlbnRDb21tYW5kLmNvbnRlbnRbMV0gLSAxXHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGlkZWFIZWFkTGV2ZWwsIGNvbnRleHRIZWFkTGV2ZWwsIGNvbnRlbnRIZWFkTGV2ZWwpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIGxldCBwcm9tcHROb2RlczogYW55W10gPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKG5vZGUuaWQgPT09IFwicm9vdFwiKSB7XHJcbiAgICAgICAgICBwcm9tcHROb2Rlcy5wdXNoKGNyZWF0ZU5vZGVEYXRhKG5vZGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBjb25zdCBmaW5kUm9vdE5vZGUgPSAoY3VycmVudE5vZGU6IGFueSwgbGV2ZWw6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcm9vdE5vZGUgPSBjdXJyZW50Tm9kZVxyXG5cclxuICAgICAgICAgICAgd2hpbGUgKGxldmVsKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHJvb3ROb2RlLmRhdGEudHlwZSA9PSAncm9vdCcgJiYgbGV2ZWwgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJvb3ROb2RlID0gcm9vdE5vZGUucGFyZW50O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBsZXZlbCA9IGxldmVsIC0gMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJvb3ROb2RlXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29uc3QgZ2V0Tm9kZXNXaXRoaW5EZXB0aCA9IChub2RlOiBhbnksIG1heERlcHRoOiBudW1iZXIsIG5vZGVUeXBlOiBzdHJpbmcsIGN1cnJlbnREZXB0aCA9IDApID0+IHtcclxuICAgICAgICAgICAgaWYgKG5vZGUgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIFtdXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50RGVwdGggPj0gbWF4RGVwdGgpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBub2RlczogYW55W10gPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQ6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmRhdGEudHlwZSA9PT0gbm9kZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChnZXROb2Rlc1dpdGhpbkRlcHRoKGNoaWxkLCBtYXhEZXB0aCwgbm9kZVR5cGUsIGN1cnJlbnREZXB0aCArIDEpKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBjb25zdCByZW1vdmVEdXBsaWNhdGVzID0gKGRhdGE6IGFueVtdKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlZW5JZHMgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YS5maWx0ZXIoaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgaWYgKHNlZW5JZHMuaGFzKGl0ZW0uaWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIER1cGxpY2F0ZSBmb3VuZCwgc2tpcCBpdFxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWVuSWRzLmFkZChpdGVtLmlkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBOb3QgYSBkdXBsaWNhdGUsIGtlZXAgaXRcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnN0IGlkZWFSb290Tm9kZSA9IGZpbmRSb290Tm9kZShub2RlLCBpZGVhSGVhZExldmVsKVxyXG4gICAgICAgICAgY29uc3QgY29udGV4dFJvb3ROb2RlID0gZmluZFJvb3ROb2RlKG5vZGUsIGNvbnRleHRIZWFkTGV2ZWwpXHJcbiAgICAgICAgICBjb25zdCBjb250ZW50Um9vdE5vZGUgPSBmaW5kUm9vdE5vZGUobm9kZSwgY29udGVudEhlYWRMZXZlbClcclxuXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhpZGVhUm9vdE5vZGUsIGNvbnRleHRSb290Tm9kZSwgY29udGVudFJvb3ROb2RlKTtcclxuXHJcbiAgICAgICAgICBpZiAoIWlkZWFSb290Tm9kZSB8fCAhY29udGV4dFJvb3ROb2RlIHx8ICFjb250ZW50Um9vdE5vZGUpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZVR5cGUgPSAhaWRlYVJvb3ROb2RlID8gXCJJZGVhc1wiIDogIWNvbnRleHRSb290Tm9kZSA/IFwiQ29udGV4dFwiIDogXCJDb250ZW50XCJcclxuXHJcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5lcnJvcih7XHJcbiAgICAgICAgICAgICAgbWVzc2FnZTogYFBsZWFzZSBjaGVjayAke25vZGVUeXBlfSdzIEhlYWQgTGV2ZWxzLiBUaGlzIHZhbHVlIGlzIHRvbyBiaWcgZm9yIHNlbGVjdGVkIG5vZGUuYFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwcm9qZWN0Q2hhbmdlZFwiKSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChcInRocmVhZElkVXBkYXRlZFwiLCB7XHJcbiAgICAgICAgICAgICAgZGV0YWlsOiB7IGtleSB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcHJvbXB0Tm9kZXMgPSBbLi4ucHJvbXB0Tm9kZXMsIC4uLmdldE5vZGVzV2l0aGluRGVwdGgoaWRlYVJvb3ROb2RlLCBpZGVhRGVwdGgsIFwiSWRlYVwiKSB8fCBbXV07XHJcbiAgICAgICAgICBwcm9tcHROb2RlcyA9IFsuLi5wcm9tcHROb2RlcywgLi4uZ2V0Tm9kZXNXaXRoaW5EZXB0aChjb250ZXh0Um9vdE5vZGUsIGNvbnRleHREZXB0aCwgXCJDb250ZXh0XCIpIHx8IFtdXTtcclxuICAgICAgICAgIHByb21wdE5vZGVzID0gWy4uLnByb21wdE5vZGVzLCAuLi5nZXROb2Rlc1dpdGhpbkRlcHRoKGNvbnRlbnRSb290Tm9kZSwgY29udGVudERlcHRoLCBcIkNvbnRlbnRcIikgfHwgW11dO1xyXG5cclxuICAgICAgICAgIGlmIChpZGVhUm9vdE5vZGUpIHtcclxuICAgICAgICAgICAgcHJvbXB0Tm9kZXMudW5zaGlmdChpZGVhUm9vdE5vZGUpXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGNvbnRleHRSb290Tm9kZSkge1xyXG4gICAgICAgICAgICBwcm9tcHROb2Rlcy51bnNoaWZ0KGNvbnRleHRSb290Tm9kZSlcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoY29udGVudFJvb3ROb2RlKSB7XHJcbiAgICAgICAgICAgIHByb21wdE5vZGVzLnVuc2hpZnQoY29udGVudFJvb3ROb2RlKVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHByb21wdE5vZGVzID0gWy4uLnJlbW92ZUR1cGxpY2F0ZXMocHJvbXB0Tm9kZXMpXVxyXG5cclxuICAgICAgICAgIGNvbnNvbGUubG9nKHByb21wdE5vZGVzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb21wdE5vZGVzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgIC8vIEV4dHJhY3QgbnVtZXJpYyBwYXJ0IGFmdGVyICcjJyBpbiBpZFxyXG4gICAgICAgICAgY29uc3QgaWRBID0gcGFyc2VJbnQoYS5pZC5zcGxpdCgnIycpWzFdLCAxMCk7XHJcbiAgICAgICAgICBjb25zdCBpZEIgPSBwYXJzZUludChiLmlkLnNwbGl0KCcjJylbMV0sIDEwKTtcclxuXHJcbiAgICAgICAgICAvLyBDb21wYXJlIHRoZSBudW1lcmljIHBhcnRzXHJcbiAgICAgICAgICByZXR1cm4gaWRBIC0gaWRCO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhwcm9tcHROb2RlcywgXCJUaGlzIGlzIG1pbmRtYXAgYXJyYXkgZGF0YSBhbmQgaXQgaXMgaW5jbHVkZSBzZWxlY3RlZCBub2RlIGFuZCBwYXJlbnQgb3IgYnJvdGhlciBub2RlcyBpZiB0aGV5IGFyZSBzZWxldGVkLlwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgeG1sRGF0YSA9IGpzb25Ub1hNTEZpbHRlcmluZyhwcm9tcHROb2Rlcyk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKHhtbERhdGEsIFwiVGhpcyBpcyBtaW5kbWFwIHhtbCBkYXRhIGFuZCBpdCBpcyBpbmNsdWRlIHNlbGVjdGVkIG5vZGUgYW5kIHBhcmVudCBvciBicm90aGVyIG5vZGVzIGlmIHRoZXkgYXJlIHNlbGV0ZWQuXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBzZWxlY3ROb2RlWG1sRGF0YSA9IGpzb25Ub1hNTFNlbGVjdE5vZGUobm9kZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdChcclxuICAgICAgICAgIFwiL2FwaS9jb21tYW5kT3BlbmFpXCIsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG9wZW5BSUtleTogb3BlbkFJS2V5LFxyXG4gICAgICAgICAgICBkZWZhdWx0QXNzaXN0YW50SWQ6IGN1cnJlbnRDb21tYW5kLmFzc2lzdGFudElkID09ICcnID8gZGVmYXVsdEFzc2lzdGFudElkIDogY3VycmVudENvbW1hbmQuYXNzaXN0YW50SWQsXHJcbiAgICAgICAgICAgIHByb21wdDogY3VycmVudENvbW1hbmQuY29tbWFuZHMsXHJcbiAgICAgICAgICAgIHRocmVhZElkOiBjdXJyZW50Q29tbWFuZC50aHJlYWRJZCA9PSAnJyA/IGRlZmF1bHRUaHJlYWRJZCA6IGN1cnJlbnRDb21tYW5kLnRocmVhZElkLFxyXG4gICAgICAgICAgICBub2RlczogeG1sRGF0YSxcclxuICAgICAgICAgICAgc2VsZWN0Tm9kZTogc2VsZWN0Tm9kZVhtbERhdGEsXHJcbiAgICAgICAgICAgIGdlbmVyYWxfcHJvbXB0OiByZXF1ZXN0SW5zdHJ1Y3Rpb25cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7IGNhbmNlbFRva2VuOiBjYW5jZWxUb2tlbiB9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgY29udGVudCA9IHJlc3BvbnNlLmRhdGEubWVzc2FnZS5jb250ZW50O1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBub2RlVHlwZTtcclxuXHJcbiAgICAgICAgaWYgKG5vZGVUeXBlICE9IFwiRWRpdCBOb2RlXCIpIHtcclxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRocmVhZElkID0gZGF0YVswXS5jb25maWd1cmF0aW9uLmRlZmF1bHRUaHJlYWRJZDtcclxuXHJcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XHJcblxyXG4gICAgICAgICAgICBjb250ZW50LmZvckVhY2goKHZhbHVlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICBsZXQgbm9kZTogTm9kZSA9IHtcclxuICAgICAgICAgICAgICAgIGlkOiBgJHt0eXBlfV8jJHtuZXcgRGF0ZSgpLmdldFRpbWUoKSArIGNvdW50fWAsXHJcbiAgICAgICAgICAgICAgICBwYXJlbnRpZDogcGFyZW50SWQsXHJcbiAgICAgICAgICAgICAgICBpc3Jvb3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdG9waWM6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIGRhdGFbMF0uZGF0YS5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDb21tYW5kLnRocmVhZElkID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgY3VycmVudENvbW1hbmQudGhyZWFkSWQgPSB0aHJlYWRJZDtcclxuXHJcbiAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJtaW5kTWFwRGF0YVwiLCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XHJcblxyXG4gICAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInByb2plY3RDaGFuZ2VkXCIpKTtcclxuXHJcbiAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJ0aHJlYWRJZFVwZGF0ZWRcIiwge1xyXG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7IGtleSB9LFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIm1pbmRNYXBEYXRhXCIsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcclxuXHJcbiAgICAgICAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicHJvamVjdENoYW5nZWRcIikpO1xyXG5cclxuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChcInRocmVhZElkVXBkYXRlZFwiLCB7XHJcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHsga2V5IH0sXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0aHJlYWRJZCA9IGRhdGFbMF0uY29uZmlndXJhdGlvbi5kZWZhdWx0VGhyZWFkSWQ7XHJcblxyXG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xyXG5cclxuICAgICAgICAgICAgbGV0IG5vZGU6IE5vZGUgPSB7XHJcbiAgICAgICAgICAgICAgaWQ6IGAke3R5cGV9XyMke25ldyBEYXRlKCkuZ2V0VGltZSgpICsgY291bnR9YCxcclxuICAgICAgICAgICAgICBwYXJlbnRpZDogcGFyZW50SWQsXHJcbiAgICAgICAgICAgICAgaXNyb290OiBmYWxzZSxcclxuICAgICAgICAgICAgICB0b3BpYzogY29udGVudCxcclxuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBkYXRhWzBdLmRhdGEucHVzaChub2RlKTtcclxuICAgICAgICAgICAgY291bnQrKztcclxuXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29tbWFuZC50aHJlYWRJZCA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICAgIGN1cnJlbnRDb21tYW5kLnRocmVhZElkID0gdGhyZWFkSWQ7XHJcblxyXG4gICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibWluZE1hcERhdGFcIiwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xyXG5cclxuICAgICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwcm9qZWN0Q2hhbmdlZFwiKSk7XHJcblxyXG4gICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFwidGhyZWFkSWRVcGRhdGVkXCIsIHtcclxuICAgICAgICAgICAgICAgIGRldGFpbDogeyBrZXkgfSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJtaW5kTWFwRGF0YVwiLCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XHJcblxyXG4gICAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInByb2plY3RDaGFuZ2VkXCIpKTtcclxuXHJcbiAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJ0aHJlYWRJZFVwZGF0ZWRcIiwge1xyXG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7IGtleSB9LFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50KSkge1xyXG4gICAgICAgICAgICBjb25zdCB0aHJlYWRJZCA9IGRhdGFbMF0uY29uZmlndXJhdGlvbi5kZWZhdWx0VGhyZWFkSWQ7XHJcblxyXG4gICAgICAgICAgICBkYXRhWzBdLmRhdGEuZm9yRWFjaCgoZWxlbWVudDogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaWQgPT09IG5vZGUuaWQpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQudG9waWMgPSBjb250ZW50WzBdO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY3VycmVudENvbW1hbmQudGhyZWFkSWQgPT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICBjdXJyZW50Q29tbWFuZC50aHJlYWRJZCA9IHRocmVhZElkO1xyXG4gICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibWluZE1hcERhdGFcIiwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibWluZE1hcERhdGFcIiwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwcm9qZWN0Q2hhbmdlZFwiKSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChcInRocmVhZElkVXBkYXRlZFwiLCB7XHJcbiAgICAgICAgICAgICAgZGV0YWlsOiB7IGtleSB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtZXNzYWdlIGNvbnRlbnRcIik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgICAgaWYgKGF4aW9zLmlzQ2FuY2VsKGVycm9yKSkge1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2Uuc3RhdHVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yU3RhdHVzID0gZXJyb3IucmVzcG9uc2Uuc3RhdHVzO1xyXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChcImVycm9yT2NjdXJzXCIsIHtcclxuICAgICAgICAgICAgICBkZXRhaWw6IHsgZXJyb3JTdGF0dXMgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG59KSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB1c2VNaW5kTWFwU3RvcmU7XHJcbiJdLCJuYW1lcyI6WyJtZXNzYWdlIiwibm90aWZpY2F0aW9uIiwiY3JlYXRlIiwiYXhpb3MiLCJsb2FkRnJvbUpTT04iLCJsb2FkRnJvbU1NIiwicmVzdG9yZURhdGEiLCJjYW5jZWxUb2tlbiIsIkNhbmNlbFRva2VuIiwiY2FuY2VsIiwiZGVmYXVsdFJldHVybkNvbW1hbmQiLCJjb21tYW5kTmFtZSIsImFzc2lzdGFudElkIiwidGhyZWFkSWQiLCJjb21tYW5kcyIsInNlbGVjdCIsImlkZWEiLCJjb250ZXh0IiwiY29udGVudCIsImNvbW1hbmRLZXkiLCJEYXRlIiwidG9TdHJpbmciLCJkZWZhdWx0TWluZE1hcCIsIm1ldGEiLCJuYW1lIiwidmVyc2lvbiIsImZvcm1hdCIsInByb2plY3ROYW1lIiwiZGF0YSIsImlkIiwiaXNyb290IiwidG9waWMiLCJ0eXBlIiwiUmVxdWVzdEluc3RydWN0aW9uIiwiY29uZmlndXJhdGlvbiIsIm9wZW5BSUtleSIsImRlZmF1bHRBc3Npc3RhbnRJZCIsImRlZmF1bHRUaHJlYWRJZCIsImNyZWF0ZU5vZGVEYXRhIiwibm9kZSIsInBhcmVudGlkIiwicGFyZW50IiwidW5kZWZpbmVkIiwianNvblRvWE1MIiwibWluZE1hcCIsImluY2x1ZGVkTm9kZUlkcyIsIlNldCIsImdldE5vZGVYTUwiLCJiYWNrZ3JvdW5kQ29sb3IiLCJjaGlsZHJlbiIsImZpbHRlciIsIm4iLCJjaGlsZHJlblhNTCIsIm1hcCIsImpvaW4iLCJhZGQiLCJyb290Tm9kZSIsImZpbmQiLCJ4bWxTdHJpbmciLCJmb3JFYWNoIiwiaGFzIiwianNvblRvWE1MRmlsdGVyaW5nIiwianNvblRvWE1MU2VsZWN0Tm9kZSIsInhtbFRvSnNvbiIsInBhcnNlciIsIkRPTVBhcnNlciIsInhtbERvYyIsInBhcnNlRnJvbVN0cmluZyIsIm5vZGVzIiwiaXNGaXJzdE5vZGUiLCJwYXJzZU5vZGUiLCJ4bWxOb2RlIiwicGFyZW50SWQiLCJnZXRBdHRyaWJ1dGUiLCJkZXRlcm1pbmVOb2RlVHlwZSIsInB1c2giLCJjaGlsZE5vZGVzIiwiaSIsImxlbmd0aCIsInJvb3RFbGVtZW50IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJjb2xvciIsInVzZU1pbmRNYXBTdG9yZSIsInNldCIsIm1pbmRzIiwiY3VycmVudE1pbmQiLCJjb21tYW5kVG9FeGVjdXRlIiwic2V0Q29tbWFuZFRvRXhlY3V0ZSIsImNvbW1hbmQiLCJzZXRNaW5kcyIsIm5ld01pbmRzIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ3aW5kb3ciLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJhZGROb2RlIiwicGFyZW50Tm9kZUlkIiwibmV3Tm9kZSIsInN0YXRlIiwibWluZCIsInBhcmVudE5vZGVFeGlzdHMiLCJzb21lIiwidXBkYXRlZE1pbmQiLCJ1cGRhdGVkTWluZHMiLCJtIiwiaW5kZXgiLCJlcnJvciIsImRlbGV0ZU5vZGUiLCJub2RlSWQiLCJkZWxldGVOb2RlQW5kQ2hpbGRyZW4iLCJjaGlsZHJlbklkcyIsImZpbHRlcmVkTm9kZXMiLCJjaGlsZElkIiwiaW5pdGlhbGl6ZU1pbmRNYXAiLCJtaW5kRGF0YSIsImdldEl0ZW0iLCJwYXJzZWRNaW5kcyIsInBhcnNlIiwiY3JlYXRlTmV3UHJvamVjdCIsIm5ld1Byb2plY3ROYW1lIiwiZXhhY3RQcm9qZWN0RXhpc3RzIiwicHJvamVjdCIsImV4aXN0aW5nUHJvamVjdHMiLCJpdGVtIiwic3RhcnRzV2l0aCIsInN1ZmZpeGVzIiwibWF0Y2giLCJSZWdFeHAiLCJwYXJzZUludCIsInN1ZmZpeCIsInNvcnQiLCJhIiwiYiIsIm5ld1N1ZmZpeCIsImNvbnNvbGUiLCJuZXdNaW5kTWFwIiwiZ2V0UHJvamVjdHMiLCJzZXRDdXJyZW50UHJvamVjdCIsInNlbGVjdGVkTWluZCIsInNldE1pbmRNYXBQcm9qZWN0TmFtZSIsImRlbGV0ZU1pbmRNYXBQcm9qZWN0Iiwic2hpZnQiLCJkb3dubG9hZEZyZWVtaW5kIiwibWluZE1hcFRvRG93bmxvYWQiLCJ4bWxEYXRhIiwiYmxvYiIsIkJsb2IiLCJ1cmwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJocmVmIiwiZG93bmxvYWQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjbGljayIsInJlbW92ZUNoaWxkIiwiZG93bmxvYWRQcm9qZWN0IiwibG9hZFByb2plY3QiLCJsb2FkRnJlZU1pbmQiLCJmaWxlIiwiZmlsZVJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJyZXN1bHQiLCJqc29uRGF0YSIsInN0b3JhZ2VEYXRhIiwiZ2V0VGltZSIsInVuc2hpZnQiLCJyZWFkQXNUZXh0Iiwic2V0UmVxdWVzdENvbnRlbnQiLCJ2YWx1ZSIsImdldERhdGFzIiwic2F2ZUNvbmZpZ3VyYXRpb25EZWZhdWx0VmFsdWUiLCJhZGRDb21tYW5kIiwiZGVsZXRlQ29tbWFuZCIsInNwbGljZSIsInNhdmVDb21tYW5kIiwiZ2V0Q29tbWFuZCIsIm1pbmRNYXBEYXRhIiwiY29tbWFuZERhdGEiLCJnZXRDb21tYW5kcyIsInNhdmVDb21tYW5kUmVvcmRlciIsInVwZGF0ZU5vZGVDb250ZW50IiwibmV3Q29udGVudCIsImdldERlZmF1bHRUaHJlYWRJZCIsImdldE9wZW5BSUtleSIsImdldERlZmF1bHRBc3Npc3RhbnRJZCIsImdldENvbmZpZ3VyYXRpb24iLCJleGVjdXRlQ29tbWFuZCIsImtleSIsIm5vZGVUeXBlIiwicmVxdWVzdEluc3RydWN0aW9uIiwiY3VycmVudENvbW1hbmQiLCJpZGVhSGVhZExldmVsIiwiaWRlYURlcHRoIiwiY29udGV4dEhlYWRMZXZlbCIsImNvbnRleHREZXB0aCIsImNvbnRlbnRIZWFkTGV2ZWwiLCJjb250ZW50RGVwdGgiLCJsb2ciLCJwcm9tcHROb2RlcyIsImZpbmRSb290Tm9kZSIsImN1cnJlbnROb2RlIiwibGV2ZWwiLCJnZXROb2Rlc1dpdGhpbkRlcHRoIiwibWF4RGVwdGgiLCJjdXJyZW50RGVwdGgiLCJjaGlsZCIsImNvbmNhdCIsInJlbW92ZUR1cGxpY2F0ZXMiLCJzZWVuSWRzIiwiaWRlYVJvb3ROb2RlIiwiY29udGV4dFJvb3ROb2RlIiwiY29udGVudFJvb3ROb2RlIiwiZXZlbnQiLCJDdXN0b21FdmVudCIsImRldGFpbCIsImlkQSIsInNwbGl0IiwiaWRCIiwic2VsZWN0Tm9kZVhtbERhdGEiLCJyZXNwb25zZSIsInBvc3QiLCJwcm9tcHQiLCJzZWxlY3ROb2RlIiwiZ2VuZXJhbF9wcm9tcHQiLCJBcnJheSIsImlzQXJyYXkiLCJjb3VudCIsImVsZW1lbnQiLCJFcnJvciIsImlzQ2FuY2VsIiwic3RhdHVzIiwiZXJyb3JTdGF0dXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/stores/mapStore.ts\n"));

/***/ })

});